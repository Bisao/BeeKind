// ... (mantenha o CSS e HTML igual) ...

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const statusMsg = document.getElementById('status');
    const joyContainer = document.getElementById('joystick-container');
    const joyKnob = document.getElementById('joystick-knob');

    // Carregamento de Sprites com verificação
    const sprites = {
        Down: new Image(), Left: new Image(), Up: new Image(), Right: new Image()
    };
    sprites.Down.src = 'BeeDown.png';
    sprites.Left.src = 'BeeLeft.png';
    sprites.Up.src = 'BeeUp.png';
    sprites.Right.src = 'BeeRight.png';

    // Log para Debug: Veja se as imagens carregaram no F12
    Object.keys(sprites).forEach(key => {
        sprites[key].onerror = () => console.error(`Erro ao carregar: Bee${key}.png`);
        sprites[key].onload = () => console.log(`Bee${key}.png carregada com sucesso!`);
    });

    let peer, conn, isHost = false;
    // Posição inicial garantida no centro
    let players = {
        me: { x: 500, y: 500, dir: 'Down' },
        peer: { x: 550, y: 500, dir: 'Down', active: false }
    };

    let camera = { x: 0, y: 0 };

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function startSession(hostMode) {
        const code = document.getElementById('room-code').value;
        if (code.length < 4) return alert("Código muito curto!");
        isHost = hostMode;
        
        // Se for Host, usa o ID fixo. Se for Client, ID aleatório.
        peer = hostMode ? new Peer('bee-' + code) : new Peer();
        
        peer.on('open', (id) => {
            console.log("Meu ID Peer:", id);
            if (hostMode) {
                statusMsg.innerText = "Aguardando amigo...";
                startGame();
            } else {
                statusMsg.innerText = "Conectando ao Host...";
                conn = peer.connect('bee-' + code);
                setupConnection();
            }
        });

        peer.on('connection', c => {
            conn = c;
            setupConnection();
        });

        peer.on('error', err => console.error("Erro Peer:", err));
    }

    function setupConnection() {
        conn.on('open', () => {
            statusMsg.innerText = "Conectado!";
            players.peer.active = true;
            if (!isHost) startGame();
        });
        conn.on('data', data => {
            players.peer = data;
            players.peer.active = true;
        });
    }

    function startGame() {
        menu.style.display = 'none';
        canvas.style.display = 'block';
        if ('ontouchstart' in window) {
            joyContainer.style.display = 'block';
            initJoystick();
        }
        gameLoop();
    }

    function updateMovement(dx, dy, speed) {
        players.me.x += dx * speed;
        players.me.y += dy * speed;

        if (Math.abs(dx) > Math.abs(dy)) {
            players.me.dir = dx > 0 ? 'Right' : 'Left';
        } else {
            players.me.dir = dy > 0 ? 'Down' : 'Up';
        }
        if (conn && conn.open) conn.send(players.me);
    }

    // Movimento Mouse PC
    window.addEventListener('mousemove', (e) => {
        if (menu.style.display === 'none' && joyContainer.style.display !== 'block') {
            const dx = e.clientX - canvas.width/2;
            const dy = e.clientY - canvas.height/2;
            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                updateMovement(dx, dy, 0.02);
            }
        }
    });

    function initJoystick() {
        let active = false;
        joyContainer.addEventListener('touchstart', () => active = true);
        window.addEventListener('touchend', () => {
            active = false;
            joyKnob.style.transform = `translate(0px, 0px)`;
        });
        window.addEventListener('touchmove', (e) => {
            if (!active) return;
            const touch = e.touches[0];
            let dx = touch.clientX - (joyContainer.offsetLeft + 50);
            let dy = touch.clientY - (joyContainer.offsetTop + 50);
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 40) { dx *= 40/dist; dy *= 40/dist; }
            joyKnob.style.transform = `translate(${dx}px, ${dy}px)`;
            updateMovement(dx, dy, 0.2);
        });
    }

    function drawBee(p, isPeer) {
        const img = sprites[p.dir];
        ctx.save();
        if (isPeer) ctx.globalAlpha = 0.7;

        // SE A IMAGEM CARREGOU, DESENHA ELA. SENÃO, DESENHA UM CÍRCULO.
        if (img.complete && img.naturalWidth !== 0) {
            ctx.drawImage(img, p.x - 32, p.y - 32, 64, 64);
        } else {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 20, 0, Math.PI*2);
            ctx.fillStyle = isPeer ? "red" : "yellow";
            ctx.fill();
        }
        ctx.restore();
    }

    function gameLoop() {
        // Câmera segue você
        camera.x = players.me.x - canvas.width / 2;
        camera.y = players.me.y - canvas.height / 2;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Desenha o outro apenas se ele enviou dados
        if (players.peer.active) {
            drawBee(players.peer, true);
        }
        
        drawBee(players.me, false);

        ctx.restore();
        requestAnimationFrame(gameLoop);
    }
</script>
