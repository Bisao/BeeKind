<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>The Hive Kingdom - Reforged</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
    :root { 
        --primary: #f1c40f; 
        --primary-dark: #b7950b;
        --secondary: #3498db;
        --bg-dark: rgba(18, 18, 18, 0.95); 
        --text-main: #ffffff; 
        --xp-color: #3498db; 
        --border: rgba(255, 255, 255, 0.1); 
        --glass: rgba(255, 255, 255, 0.05);
        --royal-gold: #ffd700;
        --danger: #e74c3c;
        --success: #2ecc71;
    }

    /* SETUP GERAL E PREVEN√á√ÉO DE ZOOM/SCROLL */
    html, body { 
        margin: 0; 
        overflow: hidden; 
        background: #0f0f0f; 
        font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
        color: var(--text-main); 
        touch-action: none; 
        user-select: none; 
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        width: 100%;
        height: 100%;
    }

    canvas { display: none; image-rendering: pixelated; width: 100%; height: 100%; }

    /* --- UI ELEMENTS --- */
    
    /* HUD SUPERIOR */
    #central-hud {
        position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center; gap: 8px;
        z-index: 100; pointer-events: none;
    }
    #lvl-hud {
        background: var(--bg-dark); padding: 10px 25px; border-radius: 25px;
        text-align: center; min-width: 220px; backdrop-filter: blur(10px);
        border: 1px solid var(--border); display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    #xp-bar-container { width: 100%; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; margin-top: 6px; overflow: hidden; }
    #xp-bar-fill { width: 0%; height: 100%; background: var(--xp-color); transition: width 0.3s; box-shadow: 0 0 8px var(--xp-color); }
    #lvl-text { font-weight: bold; color: var(--primary); font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
    #coords { 
        font-family: monospace; color: var(--primary); background: var(--bg-dark); 
        padding: 4px 15px; border-radius: 12px; font-size: 12px; 
        border: 1px solid var(--border); backdrop-filter: blur(5px);
        opacity: 0.9; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    /* ALERTA DE HORDA */
    #horde-hud {
        font-family: monospace; font-weight: 800; color: var(--danger);
        background: var(--bg-dark); padding: 5px 20px; border-radius: 12px;
        font-size: 16px; border: 1px solid rgba(231, 76, 60, 0.3);
        backdrop-filter: blur(5px); display: none; margin-top: 5px;
        text-transform: uppercase; letter-spacing: 1px;
        text-align: center; box-shadow: 0 0 15px rgba(231, 76, 60, 0.2);
    }
    .warn-pulse { animation: warnPulse 1s infinite alternate; }
    @keyframes warnPulse {
        from { transform: scale(1); opacity: 0.8; box-shadow: 0 0 10px rgba(231, 76, 60, 0.2); }
        to { transform: scale(1.05); opacity: 1; box-shadow: 0 0 25px rgba(231, 76, 60, 0.6); color: #ff6b6b; }
    }

    /* SIDEBARS (Jogadores e Colmeia) */
    #sidebar-container {
        position: absolute; left: 0; top: 100px; z-index: 101;
        display: flex; flex-direction: column; pointer-events: none;
    }
    .side-panel {
        position: relative; left: -210px; width: 210px;
        transition: left 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: auto; margin-bottom: 10px;
    }
    .side-panel.active { left: 0px; }
    .panel-content { 
        background: var(--bg-dark); padding: 15px; border-radius: 0 12px 12px 0; 
        border-left: 4px solid var(--primary); font-size: 13px; 
        backdrop-filter: blur(10px); border: 1px solid var(--border);
        box-shadow: 5px 5px 15px rgba(0,0,0,0.4); overflow: hidden;
    }
    .panel-toggle {
        position: absolute; right: -45px; top: 0;
        width: 45px; height: 45px; background: var(--primary);
        border: none; border-radius: 0 8px 8px 0; cursor: pointer;
        font-size: 20px; display: flex; align-items: center; justify-content: center;
        box-shadow: 2px 0 10px rgba(0,0,0,0.2); color: #111;
    }
    .panel-title { 
        font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid var(--primary); 
        padding-bottom: 5px; color: var(--primary); font-size: 11px; letter-spacing: 1px;
        text-transform: uppercase;
    }
    .item-row { display: flex; justify-content: space-between; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); }

    /* MENU INFERIOR */
    #bottom-menu-container {
        position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
        display: flex; flex-direction: column; align-items: center; gap: 15px;
        z-index: 500;
    }
    #main-action-menu {
        background: var(--bg-dark); border: 1px solid var(--primary);
        padding: 15px; border-radius: 15px; display: none;
        backdrop-filter: blur(10px); box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        grid-template-columns: repeat(3, 1fr); gap: 10px;
    }
    .square-btn {
        width: 50px; height: 50px; background: rgba(255,255,255,0.1);
        border: 1px solid rgba(255,255,255,0.2); border-radius: 10px;
        cursor: pointer; display: flex; align-items: center; justify-content: center;
        font-size: 24px; transition: all 0.2s;
    }
    .square-btn:hover { background: var(--primary); transform: scale(1.05); }
    #btn-open-menu {
        width: 60px; height: 60px; background: var(--primary);
        border: 4px solid rgba(0,0,0,0.2); border-radius: 50%;
        cursor: pointer; font-size: 28px; display: flex; align-items: center;
        justify-content: center; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        z-index: 501;
    }

    /* MODAIS (Morte / Game Over) */
    #death-modal, #game-over-modal { 
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
        background: rgba(0,0,0,0.85); display: none; flex-direction: column; 
        align-items: center; justify-content: center; z-index: 1000; 
    }
    .modal-title { color: var(--danger); font-size: 48px; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 5px; text-align: center; }

    /* CHAT SYSTEM */
    #chat-wrapper { 
        position: absolute; bottom: 220px; left: -240px; width: 240px; z-index: 500; 
        display: none; flex-direction: column; transition: left 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
    }
    #chat-display { 
        height: 160px; background: var(--bg-dark); border-radius: 0 12px 0 0; 
        padding: 12px; overflow-y: auto; display: flex; flex-direction: column; 
        gap: 6px; border: 1px solid var(--border); backdrop-filter: blur(15px); font-size: 13px; 
    }
    #chat-input-area { display: flex; background: rgba(30, 30, 30, 0.95); padding: 8px; border-radius: 0 0 12px 0; border: 1px solid var(--border); }
    #chat-input { flex: 1; background: transparent; border: none; color: white; padding: 4px; font-size: 14px; outline: none; }
    #btn-minimize-chat { 
        position: absolute; right: -45px; bottom: 0; 
        background: var(--primary); color: #111; border: none; border-radius: 0 8px 8px 0; 
        cursor: pointer; width: 45px; height: 45px; font-size: 20px; font-weight: bold; 
        box-shadow: 4px 0 10px rgba(0,0,0,0.3); transition: background 0.3s;
    }
    .unread-pulse { animation: pulse 1.5s infinite ease-in-out !important; z-index: 502; }
    @keyframes pulse {
        0% { transform: scale(1); box-shadow: 4px 0 10px rgba(0,0,0,0.3); }
        50% { transform: scale(1.1); box-shadow: 0 0 20px var(--primary); background: #fff176; }
        100% { transform: scale(1); box-shadow: 4px 0 10px rgba(0,0,0,0.3); }
    }

    /* LOADING SCREEN */
    #loading-screen {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: radial-gradient(circle at center, #111 0%, #000 100%);
        z-index: 4000; display: none;
        flex-direction: column; align-items: center; justify-content: center;
    }
    #loading-scene { width: 80%; max-width: 600px; height: 100px; position: relative; margin-bottom: 20px; }
    #loading-bar-track {
        position: absolute; bottom: 0; left: 0; width: 100%; height: 16px;
        background: rgba(255,255,255,0.1); border: 2px solid var(--primary); border-radius: 8px; overflow: hidden;
    }
    #loading-bar-active-fill { width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary), var(--primary-dark)); box-shadow: 0 0 10px var(--primary); }
    #loading-ant { position: absolute; bottom: 16px; left: 0; transform: translateX(-50%); font-size: 30px; transition: left 0.1s linear; }
    #loading-bee-container {
        position: absolute; bottom: 30px; left: -10%; width: 50px; height: 50px;
        transform: translateX(-50%); transition: left 0.1s linear, transform 0.3s;
    }
    #loading-bee-img { width: 100%; height: 100%; image-rendering: pixelated; animation: flightBob 0.5s infinite alternate; }
    @keyframes flightBob { from { transform: translateY(0); } to { transform: translateY(-5px); } }
    .muzzle-flash {
        position: absolute; right: -10px; top: 25px; width: 10px; height: 10px;
        background: #ffeb3b; border-radius: 50%; opacity: 0; box-shadow: 0 0 10px #ffeb3b;
        animation: shootFlash 0.3s infinite;
    }
    @keyframes shootFlash { 0% { opacity: 0; } 50% { opacity: 1; transform: scale(1.5); } 100% { opacity: 0; } }
    #loading-cookie { position: absolute; bottom: 30px; right: 30px; font-size: 40px; animation: spinCookie 2s linear infinite; }
    @keyframes spinCookie { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .explosion-text { font-size: 40px !important; animation: explodeScale 0.5s ease-out forwards; }
    @keyframes explodeScale { 0% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.5); } 100% { transform: translateX(-50%) scale(0); opacity: 0; } }

    /* MENU PRINCIPAL */
    #menu { 
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: radial-gradient(circle at center, #2c2504 0%, #000000 100%);
        z-index: 3000; padding: 20px; box-sizing: border-box; overflow: hidden;
    }
    .hex-bg {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background-image: radial-gradient(var(--royal-gold) 1px, transparent 1px);
        background-size: 40px 40px; opacity: 0.05; pointer-events: none;
        animation: panBg 60s linear infinite;
    }
    @keyframes panBg { from { background-position: 0 0; } to { background-position: 40px 40px; } }
    .pollen-particle {
        position: absolute; background: var(--primary); border-radius: 50%; opacity: 0.6;
        animation: floatUp linear infinite;
    }
    @keyframes floatUp {
        0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
        50% { opacity: 0.8; }
        100% { transform: translateY(-10vh) scale(1.2); opacity: 0; }
    }
    .menu-card {
        position: relative; background: rgba(10, 10, 10, 0.9);
        border: 2px solid var(--royal-gold); border-radius: 16px;
        padding: 40px 30px; width: 100%; max-width: 500px;
        box-shadow: 0 0 30px rgba(241, 196, 15, 0.15), inset 0 0 50px rgba(0,0,0,0.8);
        text-align: center; backdrop-filter: blur(10px); z-index: 10;
    }
    .title-box { display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 10px; padding-bottom: 15px; border-bottom: 1px solid rgba(241, 196, 15, 0.3); }
    .bee-flank { width: 50px; height: 50px; animation: swayBee 2s infinite ease-in-out alternate; image-rendering: pixelated; flex-shrink: 0; }
    .bee-left { animation-delay: 0s; } .bee-right { animation-delay: 1s; }
    @keyframes swayBee { from { transform: translateY(0) rotate(-10deg); } to { transform: translateY(-8px) rotate(10deg); } }
    .menu-card h1 {
        font-family: 'Times New Roman', serif; font-size: 2.2rem; margin: 0;
        color: var(--royal-gold); text-shadow: 0 2px 10px rgba(241, 196, 15, 0.4);
        text-transform: uppercase; letter-spacing: 2px; white-space: nowrap;
    }
    .crown-g { position: relative; display: inline-block; }
    .crown-g::before {
        content: 'üëë'; position: absolute; top: -28px; right: -4px;
        font-size: 2rem; transform: rotate(25deg); filter: drop-shadow(0 2px 2px rgba(0,0,0,0.8));
        pointer-events: none;
    }
    .update-badge {
        display: inline-block; background: linear-gradient(45deg, #b7950b, #f1c40f);
        color: #000; padding: 6px 14px; border-radius: 20px; font-size: 0.8rem;
        font-weight: bold; text-transform: uppercase; margin-bottom: 25px;
        box-shadow: 0 0 10px rgba(241, 196, 15, 0.5); animation: glowBadge 2s infinite alternate;
    }
    @keyframes glowBadge { from { box-shadow: 0 0 5px var(--primary); } to { box-shadow: 0 0 15px var(--primary); } }
    .menu-input {
        width: 100%; padding: 15px; background: rgba(0, 0, 0, 0.6);
        border: 1px solid #444; border-left: 3px solid var(--primary-dark);
        border-radius: 4px; color: #e0e0e0; font-size: 1rem; margin-bottom: 5px;
        box-sizing: border-box; transition: all 0.3s; font-family: monospace;
        user-select: text; -webkit-user-select: text;
    }
    .menu-input:focus { outline: none; border-color: var(--royal-gold); background: rgba(20, 20, 20, 0.9); box-shadow: 0 0 15px rgba(241, 196, 15, 0.1); }
    .input-group label { display: block; text-align: left; color: #aaa; font-size: 0.75rem; text-transform: uppercase; margin-bottom: 6px; margin-top: 15px; letter-spacing: 1px; }
    .button-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 25px; }
    .main-btn {
        padding: 16px; cursor: pointer; border-radius: 6px; border: none;
        font-weight: 800; font-size: 0.95rem; text-transform: uppercase;
        letter-spacing: 1px; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 8px;
        font-family: 'Segoe UI', sans-serif; position: relative; overflow: hidden;
    }
    .main-btn::after {
        content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
        background: linear-gradient(to bottom right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 100%);
        transform: rotate(45deg) translateY(-100%); transition: transform 0.5s;
    }
    .main-btn:hover::after { transform: rotate(45deg) translateY(0%); }
    .btn-create { background: linear-gradient(to bottom, #f1c40f, #d4ac0d); color: #121212; border: 1px solid #f39c12; }
    .btn-join { background: linear-gradient(to bottom, #3498db, #2980b9); color: white; border: 1px solid #2980b9; }
    #studio-footer { 
        position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
        text-align: center; pointer-events: none; z-index: 10; opacity: 0.7; font-size: 0.8rem; white-space: nowrap;
    }

    /* CONTROLES VIRTUAIS (JOYSTICK) */
    .joy-container { position: absolute; bottom: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; display: none; border: 2px solid rgba(255,255,255,0.2); z-index: 150; }
    #move-base { left: 40px; }
    #aim-base { right: 40px; border-color: rgba(255, 71, 87, 0.3); }
    .joy-stick { position: absolute; width: 50px; height: 50px; border-radius: 50%; top: 35px; left: 35px; pointer-events: none; opacity: 0.8; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }

    /* RESPONSIVIDADE */
    @media (max-width: 600px) {
        .menu-card { padding: 30px 15px; width: 95%; }
        .title-box { gap: 5px; }
        .menu-card h1 { font-size: 1.4rem; }
        .bee-flank { width: 35px; height: 35px; }
        .crown-g::before { font-size: 1.4rem; top: -18px; right: -6px; }
        .button-row { gap: 10px; }
        .main-btn { font-size: 0.8rem; padding: 14px 5px; }
    }
</style>
</head>
<body>

<div id="central-hud">
    <div id="lvl-hud">
        <div id="lvl-text">N√≠vel 1</div>
        <div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
    </div>
    <div id="coords">X: 1100 Y: 1100</div>
    <div id="horde-hud"></div>
</div>

<div id="sidebar-container">
    <div id="session-panel" class="side-panel">
        <button id="btn-session-toggle" class="panel-toggle">üë•</button>
        <div class="panel-content">
            <div class="panel-title">Sess√£o Ativa</div>
            <div id="player-items-container"></div>
        </div>
    </div>
    <div id="hive-panel" class="side-panel">
        <button id="btn-hive-toggle" class="panel-toggle">üè†</button>
        <div class="panel-content">
            <div class="panel-title">Colmeias Ativas</div>
            <div id="hive-items-container"></div>
        </div>
    </div>
</div>

<div id="bottom-menu-container">
    <div id="main-action-menu">
        <button class="square-btn" title="Abelhas">üêù</button>
        <button class="square-btn" style="opacity: 0.3;">‚öôÔ∏è</button>
        <button class="square-btn" style="opacity: 0.3;">üéí</button>
    </div>
    <button id="btn-open-menu">‚ò∞</button>
</div>

<div id="death-modal">
    <h2 class="modal-title">Derrotado</h2>
    <button class="main-btn btn-create" onclick="game.respawnPlayer()" style="width: 200px;">RESPAWN</button>
</div>
<div id="game-over-modal">
    <h2 class="modal-title">COLMEIA DESTRU√çDA</h2>
    <button class="main-btn btn-create" onclick="location.reload()" style="width: 200px;">RECOME√áAR</button>
</div>

<div id="chat-wrapper">
    <button id="btn-minimize-chat">üí¨</button>
    <div id="chat-display"></div>
    <div id="chat-input-area">
        <input type="text" id="chat-input" placeholder="Falar..." autocomplete="off">
    </div>
</div>

<div id="loading-screen">
    <div id="loading-scene">
        <div id="loading-bee-container">
            <div class="muzzle-flash"></div>
            <img src="BeeRight.png" id="loading-bee-img">
        </div>
        <div id="loading-ant">üêú</div>
        <div id="loading-bar-track">
            <div id="loading-bar-active-fill"></div>
        </div>
    </div>
    <h3 style="color:var(--primary); letter-spacing: 2px; text-transform: uppercase;">Carregando Mundo...</h3>
    <div id="loading-cookie">üç™</div>
</div>

<div id="menu">
    <div class="hex-bg"></div>
    <div class="menu-card">
        <div class="title-box">
            <img src="BeeLeft.png" class="bee-flank bee-left">
            <h1>The Hive Kin<span class="crown-g">g</span>dom</h1>
            <img src="BeeRight.png" class="bee-flank bee-right">
        </div>
        <div class="update-badge">Update: Pollen War ‚Ä¢ v1.4</div>
        <div class="input-group">
            <label>Identidade do Guerreiro</label>
            <input type="text" id="player-nick" class="menu-input" placeholder="Seu apelido..." maxlength="12">
        </div>
        <div class="input-group">
            <label>Nome do Reino (ID da Sala)</label>
            <input type="text" id="room-code" class="menu-input" placeholder="Ex: KING1" maxlength="12">
        </div>
        <div class="input-group">
            <label>Chave do Reino (Senha)</label>
            <input type="password" id="room-pass" class="menu-input" placeholder="Senha secreta..." maxlength="10">
        </div>
        <div class="button-row">
            <button class="main-btn btn-create" onclick="network.initSession(true)">
                <span>üëë</span> Criar Reino
            </button>
            <button class="main-btn btn-join" onclick="network.initSession(false)">
                <span>‚öîÔ∏è</span> Entrar
            </button>
        </div>
        <div style="margin-top: 20px; font-size: 0.8rem; color: #666; font-style: italic;">
            "Proteja a Rainha. Colete o Ouro. Sobreviva."
        </div>
    </div>
    <div id="studio-footer">FUNüç™COOK STUDIO &copy; 2025</div>
</div>

<div id="move-base" class="joy-container"><div id="move-stick" class="joy-stick" style="background:var(--primary)"></div></div>
<div id="aim-base" class="joy-container"><div id="aim-stick" class="joy-stick" style="background:#ff4757"></div></div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * THE HIVE KINGDOM - REFACTORED CORE
 * Estrutura:
 * 1. Constantes e Utils
 * 2. Gestor de Recursos (Assets)
 * 3. Gestor de Input (Touch/Teclado/Mouse)
 * 4. Gestor de Rede (PeerJS)
 * 5. L√≥gica do Jogo (Game Loop, Atualiza√ß√µes)
 * 6. Renderiza√ß√£o
 * 7. UI e DOM
 */

/* --- 1. CONSTANTES E UTILS --- */
const CONFIG = {
    TILE_SIZE: 64,
    TOTAL_WAVE_ENEMIES: 20,
    WAVE_COOLDOWN: 180, // Segundos
    LOADING_DURATION: 5000,
    HEARTBEAT_INTERVAL: 3000,
    PEER_TIMEOUT: 10000,
    XP_BASE_NEXT: 100,
    XP_FACTOR: 1.2
};

const Utils = {
    distance: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1),
    angle: (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1),
    randomId: () => Math.random().toString(36).substr(2, 9),
    getDirFromAngle: (angle) => {
        const deg = angle * (180 / Math.PI);
        if (deg >= -45 && deg <= 45) return 'Right';
        if (deg > 45 && deg < 135) return 'Down';
        if (deg >= 135 || deg <= -135) return 'Left';
        return 'Up';
    }
};

/* --- 2. ASSETS --- */
const Assets = {
    bee: { Down: new Image(), Left: new Image(), Up: new Image(), Right: new Image() },
    ground: new Image(),
    loadedCount: 0,
    total: 5,
    init: function() {
        const onLoad = () => { this.loadedCount++; };
        this.bee.Down.src = 'BeeDown.png'; this.bee.Down.onload = onLoad;
        this.bee.Left.src = 'BeeLeft.png'; this.bee.Left.onload = onLoad;
        this.bee.Up.src = 'BeeUp.png'; this.bee.Up.onload = onLoad;
        this.bee.Right.src = 'BeeRight.png'; this.bee.Right.onload = onLoad;
        this.ground.src = 'Grass.png'; this.ground.onload = onLoad;
    }
};
Assets.init();

/* --- 3. INPUT MANAGER --- */
const Input = {
    keys: {},
    mouse: { x: 0, y: 0, down: false },
    joyMove: { dx: 0, dy: 0 },
    joyAim: { angle: 0, active: false },
    touchIds: { move: null, aim: null },

    init: function() {
        window.addEventListener('keydown', e => {
            if(document.activeElement === ui.elements.chatInput) {
                if(e.key === 'Enter') { e.preventDefault(); ui.sendMsg(); }
                return;
            }
            if(e.key === 'Enter') { e.preventDefault(); ui.elements.chatInput.focus(); }
            this.keys[e.code] = true;
        });
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);
        
        // Bloqueio de gestos Safari
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault()); 
        document.addEventListener('gestureend', e => e.preventDefault());

        if('ontouchstart' in window) this.setupTouch();
    },

    setupTouch: function() {
        const moveBase = document.getElementById('move-base');
        const aimBase = document.getElementById('aim-base');
        const moveStick = document.getElementById('move-stick');
        const aimStick = document.getElementById('aim-stick');

        moveBase.style.display = 'block';
        aimBase.style.display = 'block';

        const handleStart = (e) => {
            for(let t of e.changedTouches) {
                const rM = moveBase.getBoundingClientRect();
                const rA = aimBase.getBoundingClientRect();
                
                // Check Move Stick
                if(t.clientX > rM.left && t.clientX < rM.right && t.clientY > rM.top && t.clientY < rM.bottom) {
                    this.touchIds.move = t.identifier;
                }
                // Check Aim Stick
                if(t.clientX > rA.left && t.clientX < rA.right && t.clientY > rA.top && t.clientY < rA.bottom) {
                    this.touchIds.aim = t.identifier;
                }
            }
        };

        const handleMove = (e) => {
            e.preventDefault();
            for(let t of e.touches) {
                if(t.identifier === this.touchIds.move) {
                    const r = moveBase.getBoundingClientRect();
                    const dx = t.clientX - (r.left + 60), dy = t.clientY - (r.top + 60);
                    const d = Math.min(Math.sqrt(dx*dx + dy*dy), 40), a = Math.atan2(dy, dx);
                    moveStick.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
                    this.joyMove = { dx: Math.cos(a)*(d/40), dy: Math.sin(a)*(d/40) };
                }
                if(t.identifier === this.touchIds.aim) {
                    const r = aimBase.getBoundingClientRect();
                    const dx = t.clientX - (r.left + 60), dy = t.clientY - (r.top + 60);
                    const d = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
                    this.joyAim.angle = Math.atan2(dy, dx); 
                    this.joyAim.active = true;
                    aimStick.style.transform = `translate(${Math.cos(this.joyAim.angle)*d}px, ${Math.sin(this.joyAim.angle)*d}px)`;
                }
            }
        };

        const handleEnd = (e) => {
            for(let t of e.changedTouches) {
                if(t.identifier === this.touchIds.move) { 
                    this.touchIds.move = null; 
                    this.joyMove = {dx:0, dy:0}; 
                    moveStick.style.transform = 'none'; 
                }
                if(t.identifier === this.touchIds.aim) { 
                    this.touchIds.aim = null; 
                    this.joyAim.active = false; 
                    aimStick.style.transform = 'none'; 
                }
            }
        };

        window.addEventListener('touchstart', handleStart, {passive: false});
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('touchend', handleEnd);
    }
};

/* --- 4. NETWORK MANAGER --- */
const Network = {
    peer: null,
    conn: null,
    isHost: false,
    hostPassword: "",
    lastUpdate: 0,
    lastHeartbeat: 0,

    initSession: function(isHost) {
        const nick = document.getElementById('player-nick').value.trim();
        const code = document.getElementById('room-code').value.trim();
        const pass = document.getElementById('room-pass').value.trim();

        if(!nick || !code || !pass) return alert("Preencha todos os campos!");

        // Persist√™ncia
        localStorage.setItem('hive_nick', nick);
        localStorage.setItem('hive_room', code);
        localStorage.setItem('hive_pass', pass);

        this.isHost = isHost;
        this.hostPassword = pass;
        
        // Setup Local Player
        game.state.me.nick = nick;
        game.state.me.color = isHost ? "#f1c40f" : "#3498db";
        game.state.peer.color = isHost ? "#3498db" : "#f1c40f";

        if(this.peer && !this.peer.destroyed) this.peer.destroy();

        const peerId = isHost ? 'hive-game-' + code : null;
        this.peer = new Peer(peerId);

        this.peer.on('error', err => {
            console.error(err);
            if(err.type === 'unavailable-id') alert("Nome do Reino j√° em uso!");
            else if(err.type === 'peer-unavailable') alert("Reino n√£o encontrado!");
            else alert("Erro de rede: " + err.type);
        });

        this.peer.on('open', id => {
            console.log("Connected as " + id);
            if(isHost) {
                ui.startLoading();
            } else {
                this.connectToHost(code);
            }
        });

        this.peer.on('connection', c => {
            this.conn = c;
            this.setupConnection();
        });
    },

    connectToHost: function(code) {
        this.conn = this.peer.connect('hive-game-' + code);
        setTimeout(() => {
            if(!this.conn || !this.conn.open) console.log("Tentando conectar...");
        }, 3000);
        this.setupConnection();
    },

    setupConnection: function() {
        this.conn.on('open', () => {
            // Client envia auth
            if(!this.isHost) {
                this.send({
                    type: 'auth',
                    pass: document.getElementById('room-pass').value.trim(),
                    nick: game.state.me.nick,
                    color: game.state.me.color
                });
            }
        });

        this.conn.on('data', data => this.handleData(data));
        
        this.conn.on('close', () => {
            game.state.peer.active = false;
            game.state.peer.authorized = false;
            ui.addMsg("SISTEMA", "Conex√£o perdida.", "msg-sys");
        });
    },

    send: function(data) {
        if(this.conn && this.conn.open) this.conn.send(data);
    },

    handleData: function(data) {
        // AUTHENTICATION LOGIC
        if (this.isHost && data.type === 'auth') {
            if (data.pass === this.hostPassword) {
                game.state.peer.nick = data.nick;
                game.state.peer.color = data.color;
                game.state.peer.authorized = true;
                game.state.peer.active = true;
                game.state.peer.lastSeen = Date.now();
                
                this.send({ type: 'auth_success' });
                this.send({ type: 'init_flowers', data: game.state.flowers });
                this.send({ type: 'handshake', nick: game.state.me.nick, color: game.state.me.color });
                ui.addMsg("SISTEMA", `${data.nick} entrou!`, "msg-sys");
            } else {
                this.send({ type: 'auth_fail' });
                setTimeout(() => this.conn.close(), 500);
            }
            return;
        }

        if (!this.isHost) {
            if (data.type === 'auth_success') {
                ui.startLoading();
                return;
            } else if (data.type === 'auth_fail') {
                alert("Senha Incorreta!");
                this.peer.destroy();
                return;
            }
        }

        if (this.isHost && !game.state.peer.authorized) return;

        // GAMEPLAY DATA
        switch(data.type) {
            case 'pos':
                const p = game.state.peer;
                p.tX = data.x; p.tY = data.y;
                p.dir = data.dir; p.hp = data.hp;
                p.isDead = data.isDead; p.pollen = data.pollen;
                p.lvl = data.lvl; p.active = true;
                p.lastSeen = Date.now();
                break;
            case 'shoot':
                game.spawnProjectile(data.x, data.y, data.angle, false);
                break;
            case 'chat':
                ui.addMsg(game.state.peer.nick, data.msg, "peer");
                break;
            case 'sync_world': // Client receives world state
                game.syncWorld(data);
                break;
            case 'sync_flowers_list':
                game.state.flowers = data.data;
                break;
            case 'sync_flower_cd':
                if(game.state.flowers[data.id]) game.state.flowers[data.id].cooldown = data.time;
                break;
            case 'fx':
                game.spawnEffect(data.effect, data.x, data.y);
                break;
            case 'reward_xp':
                game.addXp(data.amount);
                break;
            case 'upd_pollen':
                game.state.me.pollen = data.amount;
                break;
            case 'req_pollen': // Host receives request to collect
                 game.handlePollenRequest(data.id);
                 break;
            case 'repair': // Host receives repair request
                 game.repairHive();
                 break;
            case 'hit': // Client says "I was hit" (Trust client for self-damage in this simple model)
                 if(data.target === 'me') game.takeDamage(data.amount);
                 break;
            case 'wave_clear':
                 game.showWaveClear();
                 break;
            case 'ping': this.send({type: 'pong'}); break;
            case 'pong': game.state.peer.lastSeen = Date.now(); break;
        }
    }
};

/* --- 5. GAME ENGINE --- */
const game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d', { alpha: false }),
    
    state: {
        hive: { x: 1000, y: 1000, hp: 500, maxHp: 500, destroyed: false },
        me: { x: 1100, y: 1100, dir: 'Down', nick: "", color: "#f1c40f", hp: 100, isDead: false, pollen: 0, lvl: 1, xp: 0, nextXp: CONFIG.XP_BASE_NEXT, isCollecting: false },
        peer: { x: 1100, y: 1100, tX: 1100, tY: 1100, dir: 'Down', nick: "Amigo", color: "#3498db", active: false, hp: 100, isDead: false, pollen: 0, lvl: 1, lastSeen: 0, authorized: false },
        enemies: [],
        projectiles: [],
        particles: [],
        flowers: [],
        wave: { timer: CONFIG.WAVE_COOLDOWN, active: false, spawned: 0 },
        camera: { x: 0, y: 0 }
    },
    
    lastTime: 0,

    init: function() {
        // Carrega dados locais
        if(localStorage.getItem('hive_nick')) document.getElementById('player-nick').value = localStorage.getItem('hive_nick');
        if(localStorage.getItem('hive_room')) document.getElementById('room-code').value = localStorage.getItem('hive_room');
        if(localStorage.getItem('hive_pass')) document.getElementById('room-pass').value = localStorage.getItem('hive_pass');

        // Cria part√≠culas do menu
        const menu = document.getElementById('menu');
        for(let i=0; i<30; i++) {
            const p = document.createElement('div');
            p.classList.add('pollen-particle');
            p.style.left = Math.random() * 100 + '%';
            p.style.width = (Math.random() * 4 + 2) + 'px';
            p.style.height = p.style.width;
            p.style.animationDuration = (Math.random() * 5 + 5) + 's';
            p.style.animationDelay = (Math.random() * 5) + 's';
            menu.appendChild(p);
        }

        Input.init();
        window.addEventListener('resize', () => this.resize());
        this.resize();
        
        // Loop
        requestAnimationFrame(t => this.loop(t));
    },

    resize: function() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    },

    startGame: function() {
        if(Network.isHost) this.generateFlowers();
        
        // Show Game UI
        document.getElementById('menu').style.display = 'none';
        document.getElementById('loading-screen').style.display = 'none';
        document.getElementById('lvl-hud').style.display = 'block';
        document.getElementById('chat-wrapper').style.display = 'flex';
        document.getElementById('session-panel').style.display = 'block';
        document.getElementById('hive-panel').style.display = 'block';
        this.canvas.style.display = 'block';
    },

    generateFlowers: function() {
        this.state.flowers = [];
        const types = ["üå∏", "üåª", "üå∑"];
        for(let i=0; i<25; i++) {
            this.state.flowers.push({
                id: i,
                x: Math.random() * 4000 - 1000, y: Math.random() * 4000 - 1000,
                emoji: types[Math.floor(Math.random() * types.length)],
                cooldown: 0, maxCooldown: 300, phase: Math.random() * Math.PI * 2,
                growState: 'mature', plantTime: 0
            });
        }
    },

    spawnProjectile: function(x, y, angle, isMe) {
        this.state.projectiles.push({
            x, y, vx: Math.cos(angle)*12, vy: Math.sin(angle)*12, 
            life: 60, color: isMe ? this.state.me.color : this.state.peer.color, 
            owner: isMe ? 'me' : 'peer'
        });
    },

    spawnEffect: function(type, x, y) {
        if(type === 'damage') this.createParticles(x, y, "#ff0000", 8);
        else if(type === 'death') this.createParticles(x, y, "#000", 12);
        else if(type === 'heart') this.createParticles(x, y, "#ff4d4d", 15, 'heart');
    },

    createParticles: function(x, y, color, count, type = 'pixel') {
        for(let i=0; i<count; i++) {
            let vx = (Math.random() - 0.5) * 4;
            let vy = (Math.random() - 0.5) * 4;
            let decay = Math.random() * 0.02 + 0.01;
            if(type === 'pollen') { vx *= 0.4; vy = Math.abs(vy)*0.4; decay = 0.03; }
            if(type === 'heart') { vx *= 0.5; vy = -Math.random(); decay = 0.01; }
            this.state.particles.push({ x, y, vx, vy, life: 1.0, decay, color, type });
        }
    },

    addXp: function(amount) {
        if(this.state.me.isDead) return;
        this.state.me.xp += amount;
        if(this.state.me.xp >= this.state.me.nextXp) {
            this.state.me.xp -= this.state.me.nextXp;
            this.state.me.lvl++;
            this.state.me.nextXp = Math.floor(CONFIG.XP_BASE_NEXT * Math.pow(CONFIG.XP_FACTOR, this.state.me.lvl));
            ui.addMsg("SISTEMA", `LEVEL UP! N√≠vel ${this.state.me.lvl}!`, "msg-sys");
            this.createParticles(this.state.me.x, this.state.me.y, "#f1c40f", 20);
        }
        ui.updateXp();
    },

    takeDamage: function(amount) {
        if(this.state.me.isDead) return;
        this.state.me.hp -= amount;
        this.createParticles(this.state.me.x, this.state.me.y, "#ff0000", 5);
        if(this.state.me.hp <= 0) {
            this.state.me.hp = 0; this.state.me.isDead = true;
            this.state.me.pollen = 0;
            document.getElementById('death-modal').style.display = 'flex';
        }
    },

    respawnPlayer: function() {
        this.state.me.x = 1100; this.state.me.y = 1100;
        this.state.me.hp = 100; this.state.me.isDead = false;
        document.getElementById('death-modal').style.display = 'none';
    },

    repairHive: function() {
        if(Network.isHost) {
            this.state.hive.hp = Math.min(this.state.hive.maxHp, this.state.hive.hp + 50);
            this.spawnEffect('heart', this.state.hive.x, this.state.hive.y);
            this.addXp(15);
            Network.send({ type: 'fx', effect: 'heart', x: this.state.hive.x, y: this.state.hive.y });
            Network.send({ type: 'reward_xp', amount: 15 });
        } else {
            Network.send({ type: 'repair' });
        }
    },

    handlePollenRequest: function(flowerId) {
        const f = this.state.flowers[flowerId];
        if(f && f.growState === 'mature' && f.cooldown <= 0) {
            f.cooldown = f.maxCooldown;
            this.state.peer.pollen += 0.4;
            Network.send({ type: 'upd_pollen', amount: this.state.peer.pollen });
            Network.send({ type: 'sync_flower_cd', id: flowerId, time: f.maxCooldown });
        }
    },

    showWaveClear: function() {
        ui.addMsg("SISTEMA", "HORDA DESTRU√çDA! +3 Minutos de Paz.", "msg-sys");
        this.createParticles(this.state.hive.x, this.state.hive.y, "#3498db", 30);
    },

    syncWorld: function(data) {
        this.state.peer.lastSeen = Date.now();
        // Sync simples de inimigos (reconcilia√ß√£o b√°sica)
        this.state.enemies = data.enemies.map(enNew => {
            let existing = this.state.enemies.find(e => e.id === enNew.id);
            return existing ? {...enNew} : enNew;
        });
        this.state.wave.active = data.isWaveActive;
        this.state.hive.hp = data.hiveHp;
        this.state.wave.timer = data.waveTimer;
        this.state.wave.spawned = data.enemiesSpawned;
    },

    loop: function(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = timestamp - this.lastTime;
        
        // Verifica se jogo come√ßou
        if(this.canvas.style.display === 'block') {
            this.update();
            this.draw();
        }

        this.lastTime = timestamp;
        requestAnimationFrame(t => this.loop(t));
    },

    update: function() {
        const me = this.state.me;
        const peer = this.state.peer;
        
        // --- 1. PLAYER MOVEMENT & INPUT ---
        if(!me.isDead) {
            let dx = Input.joyMove.dx, dy = Input.joyMove.dy;
            if (Input.keys['KeyW'] || Input.keys['ArrowUp']) dy = -1;
            if (Input.keys['KeyS'] || Input.keys['ArrowDown']) dy = 1;
            if (Input.keys['KeyA'] || Input.keys['ArrowLeft']) dx = -1;
            if (Input.keys['KeyD'] || Input.keys['ArrowRight']) dx = 1;

            if (dx !== 0 || dy !== 0) {
                const m = Math.sqrt(dx*dx + dy*dy);
                me.x += (dx/m) * 5; me.y += (dy/m) * 5;
                if (!Input.joyAim.active && !Input.mouse.down) {
                    me.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'Right' : 'Left') : (dy > 0 ? 'Down' : 'Up');
                }
            }

            // Shooting
            let shootAngle = null;
            if(Input.joyAim.active) shootAngle = Input.joyAim.angle;
            else if(Input.mouse.down) shootAngle = Math.atan2(Input.mouse.y - this.canvas.height/2, Input.mouse.x - this.canvas.width/2);

            if(shootAngle !== null) {
                me.dir = Utils.getDirFromAngle(shootAngle);
                if(Date.now() - Network.lastUpdate > 180) { // Shoot Cooldown Reuse variable
                     this.spawnProjectile(me.x, me.y, shootAngle, true);
                     Network.send({ type: 'shoot', x: me.x, y: me.y, angle: shootAngle });
                     Network.lastUpdate = Date.now(); // reusing timer var name for shoot cd locally
                }
            }
        }

        // --- 2. PEER INTERPOLATION ---
        if(peer.active) {
            peer.x += (peer.tX - peer.x) * 0.15;
            peer.y += (peer.tY - peer.y) * 0.15;
            // Timeout check
            if(Date.now() - peer.lastSeen > CONFIG.PEER_TIMEOUT) {
                peer.active = false;
                ui.addMsg("SISTEMA", `${peer.nick} desconectou (Timeout).`, "msg-sys");
            }
        }

        // --- 3. WAVE LOGIC (HOST ONLY) ---
        if(Network.isHost) {
            // Heartbeat
            if(Date.now() - Network.lastHeartbeat > CONFIG.HEARTBEAT_INTERVAL) {
                Network.send({type: 'ping'});
                Network.lastHeartbeat = Date.now();
            }

            this.state.wave.timer -= 1/60;
            if(this.state.wave.timer <= 0 && !this.state.wave.active) {
                this.state.wave.active = true;
                this.state.wave.spawned = 0;
                this.state.wave.timer = CONFIG.WAVE_COOLDOWN;
            }

            // Wave clear check
            if (this.state.wave.active && this.state.enemies.length === 0 && this.state.wave.spawned >= CONFIG.TOTAL_WAVE_ENEMIES) {
                this.state.wave.active = false;
                this.state.wave.timer = CONFIG.WAVE_COOLDOWN;
                this.showWaveClear();
                Network.send({type: 'wave_clear'});
            }

            // Spawning
            if (this.state.wave.active && this.state.wave.spawned < CONFIG.TOTAL_WAVE_ENEMIES && Date.now() - Network.lastUpdate > 2000) { // Reuse timer for spawn
                 // Actually logic needs separate timer
                 if(!this.lastSpawnTime) this.lastSpawnTime = 0;
                 if(Date.now() - this.lastSpawnTime > 2000) {
                     const angle = Math.random() * Math.PI * 2;
                     this.state.enemies.push({
                         id: Utils.randomId(),
                         x: this.state.hive.x + Math.cos(angle) * 1000,
                         y: this.state.hive.y + Math.sin(angle) * 1000,
                         hp: 100, vx: 0, vy: 0,
                         behavior: Math.random() < 0.35 ? 'hunter' : 'rusher'
                     });
                     this.state.wave.spawned++;
                     this.lastSpawnTime = Date.now();
                 }
            }

            // Enemy Logic
            this.state.enemies.forEach(en => {
                let tX = this.state.hive.x, tY = this.state.hive.y;
                if (en.behavior === 'hunter') {
                    let dMe = !me.isDead ? Utils.distance(en.x, en.y, me.x, me.y) : Infinity;
                    let dPeer = (peer.active && !peer.isDead) ? Utils.distance(en.x, en.y, peer.x, peer.y) : Infinity;
                    if (dMe < Infinity || dPeer < Infinity) {
                        if (dMe <= dPeer) { tX = me.x; tY = me.y; } else { tX = peer.x; tY = peer.y; }
                    }
                }
                const a = Utils.angle(en.x, en.y, tX, tY);
                en.vx = Math.cos(a) * 2; en.vy = Math.sin(a) * 2;
                en.x += en.vx; en.y += en.vy;

                // Damage Logic
                if (!this.state.hive.destroyed && Utils.distance(en.x, en.y, this.state.hive.x, this.state.hive.y) < 50) {
                     if(Math.random() < 0.05) this.state.hive.hp -= 2;
                }
                if (Utils.distance(en.x, en.y, me.x, me.y) < 30 && Math.random() < 0.05) this.takeDamage(2);
                if (peer.active && !peer.isDead && Utils.distance(en.x, en.y, peer.x, peer.y) < 30 && Math.random() < 0.05) {
                    Network.send({type:'hit', target:'me', amount: 2});
                }
            });
            this.state.enemies = this.state.enemies.filter(e => e.hp > 0);

            // Hive Death
            if (this.state.hive.hp <= 0 && !this.state.hive.destroyed) {
                this.state.hive.hp = 0; this.state.hive.destroyed = true;
                setTimeout(() => document.getElementById('game-over-modal').style.display = 'flex', 1500);
            }

            // Sync World
            if(!this.lastSync) this.lastSync = 0;
            if(peer.active && Date.now() - this.lastSync > 50) {
                Network.send({ 
                    type: 'sync_world', 
                    enemies: this.state.enemies.map(e => ({id: e.id, x: e.x, y: e.y, vx: e.vx, vy: e.vy, hp: e.hp})), 
                    isWaveActive: this.state.wave.active, hiveHp: this.state.hive.hp,
                    waveTimer: this.state.wave.timer, enemiesSpawned: this.state.wave.spawned 
                });
                this.lastSync = Date.now();
            }
        } else {
            // CLIENT PREDICTION (Simples)
            this.state.enemies.forEach(en => { en.x += en.vx; en.y += en.vy; });
        }

        // --- 4. PROJECTILES & COLLISIONS ---
        for (let i = this.state.projectiles.length - 1; i >= 0; i--) {
            let p = this.state.projectiles[i];
            let hit = false;
            // Collision with enemies
            for (let j = 0; j < this.state.enemies.length; j++) {
                let en = this.state.enemies[j];
                if(Utils.distance(p.x, p.y, en.x, en.y) < 35) {
                    if(Network.isHost) {
                        en.hp -= 25;
                        this.spawnEffect('damage', en.x, en.y);
                        Network.send({ type: 'fx', effect: 'damage', x: en.x, y: en.y });
                        if(en.hp <= 0) {
                            this.spawnEffect('death', en.x, en.y);
                            Network.send({ type: 'fx', effect: 'death', x: en.x, y: en.y });
                            const xp = 30;
                            if(peer.active && !peer.isDead) {
                                this.addXp(xp/2); Network.send({ type: 'reward_xp', amount: xp/2 });
                            } else { this.addXp(xp); }
                        }
                    }
                    hit = true; break;
                }
            }
            if(hit) { this.state.projectiles.splice(i, 1); continue; }
            p.x += p.vx; p.y += p.vy; p.life--;
            if(p.life <= 0) this.state.projectiles.splice(i, 1);
        }

        // --- 5. PARTICLES ---
        for (let i = this.state.particles.length - 1; i >= 0; i--) {
            let p = this.state.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= p.decay;
            if(p.life <= 0) this.state.particles.splice(i, 1);
        }

        // --- 6. MECHANICS (Flowers/Pollen/Hive) ---
        // Flower Logic (Host Only Spawn)
        if(Network.isHost) {
            // Host move pollen gen
            if(me.pollen > 0 && !me.isDead && (Math.abs(Input.joyMove.dx) > 0 || Math.abs(Input.joyMove.dy) > 0)) {
                if(Math.random() < 0.3) this.createParticles(me.x, me.y, "#fffa65", 1, 'pollen');
                me.pollen = Math.max(0, me.pollen - 0.05);
                if(Math.random() < 0.002) this.spawnFlower(me.x, me.y);
            }
            // Peer move pollen gen assumption
            if(peer.active && !peer.isDead && peer.pollen > 0 && Math.random() < 0.05) {
                if(Math.random() < 0.3) this.createParticles(peer.x, peer.y, "#fffa65", 1, 'pollen');
                if(Math.random() < 0.002) this.spawnFlower(peer.x, peer.y);
            }
            
            // Grow logic
            let sync = false;
            const now = Date.now();
            this.state.flowers.forEach(f => {
                if(f.growState !== 'mature') {
                    const age = now - f.plantTime;
                    if(f.growState === 'seed' && age >= 120000) { f.growState = 'sprout'; sync = true; }
                    if(f.growState === 'sprout' && age >= 300000) { f.growState = 'mature'; sync = true; }
                }
            });
            if(sync) Network.send({ type: 'sync_flowers_list', data: this.state.flowers });
        }

        // Collection Logic
        this.state.flowers.forEach((f, idx) => {
            if(f.growState === 'mature') {
                if(f.cooldown > 0) f.cooldown -= 1/60;
                else if(Utils.distance(me.x, me.y, f.x, f.y) < 50 && me.pollen < 100) {
                    me.isCollecting = true;
                    if(Network.isHost) {
                        me.pollen += 0.4; this.addXp(0.02);
                        if(me.pollen >= 100) {
                            me.pollen = 100; f.cooldown = f.maxCooldown;
                            if(peer.active) Network.send({ type: 'sync_flower_cd', id: idx, time: f.maxCooldown });
                        }
                    } else if(Math.random() < 0.1) {
                        Network.send({ type: 'req_pollen', id: idx });
                    }
                }
            }
        });

        // Hive Interaction
        if(Utils.distance(me.x, me.y, this.state.hive.x, this.state.hive.y) < 60 && !this.state.hive.destroyed) {
            if(me.pollen >= 100 && this.state.hive.hp < this.state.hive.maxHp) {
                me.pollen = 0;
                // Healing Mechanic
                if(me.hp < 100) {
                    me.hp = Math.min(100, me.hp + 1);
                    this.createParticles(me.x, me.y, "#2ecc71", 10);
                    ui.addMsg("SISTEMA", "Curado (+1 HP) pelo P√≥len.", "msg-sys");
                }
                this.repairHive();
            }
        }

        // Send Pos
        if(!this.lastPosSync) this.lastPosSync = 0;
        if(Date.now() - this.lastPosSync > 30 && Network.conn && Network.conn.open) {
            Network.send({ ...me, type: 'pos' });
            this.lastPosSync = Date.now();
        }

        ui.updateHud();
    },

    spawnFlower: function(x, y) {
        const types = ["üå∏", "üåª", "üå∑"];
        this.state.flowers.push({
            id: this.state.flowers.length,
            x, y, emoji: types[Math.floor(Math.random() * types.length)],
            cooldown: 0, maxCooldown: 300, phase: Math.random() * Math.PI * 2,
            growState: 'seed', plantTime: Date.now()
        });
        if(Network.conn) Network.send({ type: 'sync_flowers_list', data: this.state.flowers });
    },

    draw: function() {
        const { width, height } = this.canvas;
        const { me, peer, hive, flowers, enemies, projectiles, particles, camera } = this.state;
        const ctx = this.ctx;

        // Camera follow
        camera.x = me.x - width/2;
        camera.y = me.y - height/2;

        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,width,height);
        
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Ground
        const sX = Math.floor(camera.x/CONFIG.TILE_SIZE)*CONFIG.TILE_SIZE;
        const sY = Math.floor(camera.y/CONFIG.TILE_SIZE)*CONFIG.TILE_SIZE;
        for(let x=sX; x<sX+width+CONFIG.TILE_SIZE; x+=CONFIG.TILE_SIZE) 
            for(let y=sY; y<sY+height+CONFIG.TILE_SIZE; y+=CONFIG.TILE_SIZE) 
                if(Assets.ground.complete) ctx.drawImage(Assets.ground, x, y, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

        // Flowers
        ctx.font = "28px Arial"; ctx.textAlign = "center";
        flowers.forEach(f => {
            if(f.growState === 'seed') return;
            const sway = Math.sin(performance.now() * 0.003 + f.phase) * 5;
            ctx.globalAlpha = f.cooldown > 0 ? 0.5 : 1.0;
            ctx.fillText(f.growState === 'sprout' ? "üå±" : f.emoji, f.x + sway, f.y);
        });
        ctx.globalAlpha = 1.0;

        // Hive
        if(!hive.destroyed) {
            ctx.font = "60px Arial"; ctx.fillText("üè†", hive.x, hive.y + 20);
            this.drawBar(hive.x, hive.y, hive.hp, hive.maxHp, 100, 10, 60);
        }

        // Indicators
        if(peer.active && !peer.isDead && Utils.distance(me.x, me.y, peer.x, peer.y) > width/2) 
            this.drawArrow(peer.x - me.x, peer.y - me.y, peer.color);
        if(!hive.destroyed && Utils.distance(me.x, me.y, hive.x, hive.y) > width/2)
            this.drawArrow(hive.x - me.x, hive.y - me.y, "#f1c40f", 90);

        // Enemies
        ctx.font = "30px Arial";
        enemies.forEach(en => {
            ctx.fillText("üêú", en.x, en.y);
            this.drawBar(en.x, en.y, en.hp, 100, 30, 4, 30);
        });

        // Projectiles
        projectiles.forEach(p => {
            ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
        });

        // Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            if(p.type === 'heart') { ctx.font = "20px Arial"; ctx.fillText("‚ù§Ô∏è", p.x, p.y); }
            else { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3); }
        });
        ctx.globalAlpha = 1.0;

        // Players
        this.drawPlayer(me, 1.0);
        if(peer.active) this.drawPlayer(peer, 0.6);

        ctx.restore();
    },

    drawPlayer: function(p, alpha) {
        if(p.isDead) return;
        if(Assets.bee[p.dir].complete) {
            this.ctx.globalAlpha = alpha;
            this.ctx.drawImage(Assets.bee[p.dir], p.x-32, p.y-32, 64, 64);
        }
        this.ctx.globalAlpha = 1; 
        this.ctx.font = "bold 14px Segoe UI"; 
        this.ctx.fillStyle = p.color; 
        this.ctx.textAlign = "center"; 
        this.ctx.fillText(`${p.nick} (Lvl ${p.lvl})`, p.x, p.y-40);
        this.drawBar(p.x, p.y, p.hp, 100, 50, 6, 55);
        if(p.isCollecting || p.pollen > 0) this.drawBar(p.x, p.y, p.pollen, 100, 50, 6, -40, "#fffa65");
    },

    drawBar: function(x, y, val, max, w, h, offset, color = null) {
        const p = val / max;
        this.ctx.fillStyle = "rgba(0,0,0,0.5)"; this.ctx.fillRect(x - w/2, y - offset, w, h);
        this.ctx.fillStyle = color ? color : (p > 0.3 ? "#2ecc71" : "#e74c3c");
        this.ctx.fillRect(x - w/2, y - offset, w * p, h);
        if(color) { this.ctx.strokeStyle = "rgba(0,0,0,0.3)"; this.ctx.lineWidth = 1; this.ctx.strokeRect(x - w/2, y - offset, w, h); }
    },

    drawArrow: function(dx, dy, color, radius = 70) {
        const angle = Math.atan2(dy, dx);
        this.ctx.save(); 
        this.ctx.translate(this.state.me.x, this.state.me.y); 
        this.ctx.rotate(angle);
        this.ctx.beginPath(); this.ctx.moveTo(radius, 0); 
        this.ctx.lineTo(radius - 15, -8); this.ctx.lineTo(radius - 15, 8); 
        this.ctx.closePath();
        this.ctx.fillStyle = color; this.ctx.fill(); 
        this.ctx.restore();
    }
};

/* --- 6. UI MANAGER --- */
const ui = {
    elements: {
        chatDisplay: document.getElementById('chat-display'),
        chatInput: document.getElementById('chat-input'),
        chatWrapper: document.getElementById('chat-wrapper'),
        playerContainer: document.getElementById('player-items-container'),
        hiveContainer: document.getElementById('hive-items-container'),
        coords: document.getElementById('coords'),
        horde: document.getElementById('horde-hud'),
        menuBtn: document.getElementById('btn-open-menu'),
        menu: document.getElementById('main-action-menu')
    },

    init: function() {
        this.elements.menuBtn.onclick = () => {
            const vis = this.elements.menu.style.display === 'grid';
            this.elements.menu.style.display = vis ? 'none' : 'grid';
            this.elements.menuBtn.innerHTML = vis ? '‚ò∞' : '‚úï';
        };

        const chatToggle = document.getElementById('btn-minimize-chat');
        const toggleChat = () => {
            let left = window.getComputedStyle(this.elements.chatWrapper).getPropertyValue('left');
            let hidden = left.includes('-') || left === 'auto';
            this.elements.chatWrapper.style.left = hidden ? "0px" : "-240px";
            chatToggle.innerHTML = hidden ? "¬´" : "üí¨";
            if(hidden) chatToggle.classList.remove('unread-pulse');
        };
        chatToggle.onclick = toggleChat;
        chatToggle.ontouchstart = (e) => { e.preventDefault(); toggleChat(); };

        document.getElementById('btn-session-toggle').onclick = (e) => {
            const p = document.getElementById('session-panel');
            p.classList.toggle('active');
            e.target.innerHTML = p.classList.contains('active') ? "¬´" : "üë•";
        };
        document.getElementById('btn-hive-toggle').onclick = (e) => {
            const p = document.getElementById('hive-panel');
            p.classList.toggle('active');
            e.target.innerHTML = p.classList.contains('active') ? "¬´" : "üè†";
        };
    },

    startLoading: function() {
        document.getElementById('menu').style.display = 'none';
        const scr = document.getElementById('loading-screen');
        scr.style.display = 'flex';
        const bar = document.getElementById('loading-bar-active-fill');
        const ant = document.getElementById('loading-ant');
        const bee = document.getElementById('loading-bee-container');
        const beeImg = document.getElementById('loading-bee-img');
        const start = Date.now();
        let exploded = false;

        const frame = () => {
            const pct = Math.min(1, (Date.now() - start) / CONFIG.LOADING_DURATION);
            if(pct < 1) {
                bar.style.width = (pct*100)+'%'; ant.style.left = (pct*100)+'%';
                bee.style.left = Math.max(0, (pct*100)-1)+'%';
                requestAnimationFrame(frame);
            } else if (!exploded) {
                exploded = true;
                bar.style.width = '100%'; ant.innerText = "üí•"; ant.classList.add('explosion-text');
                document.querySelector('.muzzle-flash').style.display = 'none';
                beeImg.src = 'BeeDown.png'; beeImg.style.animation = 'none';
                bee.style.transition = 'left 0.5s ease-out'; bee.style.left = '50%';
                setTimeout(() => game.startGame(), 1000);
            }
        };
        requestAnimationFrame(frame);
    },

    updateXp: function() {
        const me = game.state.me;
        document.getElementById('xp-bar-fill').style.width = (me.xp/me.nextXp)*100 + "%";
        document.getElementById('lvl-text').innerText = `N√≠vel ${me.lvl}`;
    },

    updateHud: function() {
        const { me, peer, hive, wave } = game.state;
        this.elements.coords.innerText = `X: ${Math.floor(me.x)} Y: ${Math.floor(me.y)}`;

        // Players
        let html = `<div class="item-row" style="color:${me.color}"><span>‚óè Voc√™ (${me.nick})</span><span>Lvl ${me.lvl}</span></div>`;
        if(peer.active) {
            const d = Math.floor(Utils.distance(me.x, me.y, peer.x, peer.y)/10);
            html += `<div class="item-row" style="color:${peer.color}"><span>‚óè ${peer.nick}</span><span>${d}m</span></div>`;
        }
        this.elements.playerContainer.innerHTML = html;

        // Hive
        if(!hive.destroyed) {
            const hpP = Math.floor((hive.hp/hive.maxHp)*100);
            const dist = Math.floor(Utils.distance(me.x, me.y, hive.x, hive.y)/10);
            this.elements.hiveContainer.innerHTML = `<div class="item-row" style="color:${hpP>30?'#2ecc71':'#e74c3c'}"><span>üè† Base</span><span>${hpP}% (${dist}m)</span></div>`;
        } else {
            this.elements.hiveContainer.innerHTML = `<div class="item-row" style="color:#e74c3c"><span>Destru√≠da</span></div>`;
        }

        // Horde Alert
        if(wave.active) {
            this.elements.horde.style.display = 'block';
            this.elements.horde.classList.remove('warn-pulse');
            this.elements.horde.style.color = '#ff4757';
            const rem = (CONFIG.TOTAL_WAVE_ENEMIES - wave.spawned) + game.state.enemies.length;
            this.elements.horde.innerText = `‚ö†Ô∏è INVAS√ÉO: ${rem} ‚ö†Ô∏è`;
        } else if (wave.timer <= 60) {
            this.elements.horde.style.display = 'block';
            this.elements.horde.classList.add('warn-pulse');
            this.elements.horde.style.color = '#e67e22';
            this.elements.horde.innerText = `ALERTA: ${Math.ceil(wave.timer)}s`;
        } else {
            this.elements.horde.style.display = 'none';
        }
    },

    sendMsg: function() {
        const txt = this.elements.chatInput.value.trim();
        if(!txt) return;
        this.addMsg(game.state.me.nick, txt, "me");
        Network.send({ type: 'chat', msg: txt });
        this.elements.chatInput.value = "";
        this.elements.chatInput.blur();
    },

    addMsg: function(author, text, type) {
        const d = document.createElement('div');
        const color = type === "me" ? game.state.me.color : (type === "peer" ? game.state.peer.color : "#aaa");
        d.innerHTML = `<span style="color:${color}; font-weight:bold">${author}:</span> ${text}`;
        this.elements.chatDisplay.appendChild(d);
        this.elements.chatDisplay.scrollTop = this.elements.chatDisplay.scrollHeight;
        
        const wrap = this.elements.chatWrapper;
        if(window.getComputedStyle(wrap).left.includes('-') && type !== "msg-sys") {
            document.getElementById('btn-minimize-chat').classList.add('unread-pulse');
        }
    }
};

/* --- BOOTSTRAP --- */
ui.init();
const network = Network; // Expose to global for button onclick
game.init();

</script>
</body>
</html>
