<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>The Hive Kingdom</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
:root { 
--primary: #f1c40f; 
--primary-dark: #b7950b;
--secondary: #3498db;
--bg-dark: rgba(18, 18, 18, 0.95); 
--text-main: #ffffff; 
--xp-color: #3498db; 
--border: rgba(255, 255, 255, 0.1); 
--glass: rgba(255, 255, 255, 0.05);
--royal-gold: #ffd700;
--royal-bg: #1a1a1a;
}

html, body { 
margin: 0; 
overflow: hidden; 
background: #0f0f0f; 
font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
color: var(--text-main); 
touch-action: none; 
user-select: none; 
-webkit-user-select: none; 
-webkit-touch-callout: none; 
}

canvas { display: none; image-rendering: pixelated; }

#central-hud {
position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
display: flex; flex-direction: column; align-items: center; gap: 8px;
z-index: 100; pointer-events: none;
}

#lvl-hud {
background: var(--bg-dark); padding: 10px 25px; border-radius: 25px;
text-align: center; min-width: 220px; backdrop-filter: blur(10px);
border: 1px solid var(--border); display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

/* Alterado para lateral esquerda superior */
#time-hud {
position: absolute; top: 15px; left: 15px;
background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 15px;
font-size: 12px; font-weight: bold; color: #fff; margin-top: 5px;
font-size: 12px; font-weight: bold; color: #fff;
border: 1px solid var(--border); backdrop-filter: blur(5px);
display: none; align-items: center; gap: 8px;
z-index: 105;
}

#xp-bar-container { width: 100%; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; margin-top: 6px; overflow: hidden; }
#xp-bar-fill { width: 0%; height: 100%; background: var(--xp-color); transition: width 0.3s; box-shadow: 0 0 8px var(--xp-color); }
#lvl-text { font-weight: bold; color: var(--primary); font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
#coords { 
font-family: monospace; color: var(--primary); background: var(--bg-dark); 
padding: 4px 15px; border-radius: 12px; font-size: 12px; 
border: 1px solid var(--border); backdrop-filter: blur(5px);
opacity: 0.9; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
}

#horde-hud {
font-family: monospace; font-weight: 800; color: #e74c3c;
background: var(--bg-dark); padding: 5px 20px; border-radius: 12px;
font-size: 16px; border: 1px solid rgba(231, 76, 60, 0.3);
backdrop-filter: blur(5px); display: none; margin-top: 5px;
text-transform: uppercase; letter-spacing: 1px;
text-align: center; box-shadow: 0 0 15px rgba(231, 76, 60, 0.2);
}

.warn-pulse { animation: warnPulse 1s infinite alternate; }
@keyframes warnPulse {
from { transform: scale(1); opacity: 0.8; box-shadow: 0 0 10px rgba(231, 76, 60, 0.2); }
to { transform: scale(1.05); opacity: 1; box-shadow: 0 0 25px rgba(231, 76, 60, 0.6); color: #ff6b6b; }
}

#sidebar-container {
position: absolute; left: 0; top: 100px; z-index: 101;
display: flex; flex-direction: column; pointer-events: none;
}
.side-panel {
position: relative; left: -210px; width: 210px;
transition: left 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
pointer-events: auto;
}
.side-panel.active { left: 0px; }
.panel-content { 
background: var(--bg-dark); padding: 15px; border-radius: 0 12px 12px 0; 
border-left: 4px solid var(--primary); font-size: 13px; 
backdrop-filter: blur(10px); border: 1px solid var(--border);
box-shadow: 5px 5px 15px rgba(0,0,0,0.4);
overflow: hidden;
}
.panel-toggle {
position: absolute; right: -45px; top: 0;
width: 45px; height: 45px; background: var(--primary);
border: none; border-radius: 0 8px 8px 0; cursor: pointer;
font-size: 20px; display: flex; align-items: center; justify-content: center;
box-shadow: 2px 0 10px rgba(0,0,0,0.2); color: #111;
}
.panel-title { 
font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid var(--primary); 
padding-bottom: 5px; color: var(--primary); font-size: 11px; letter-spacing: 1px;
text-transform: uppercase;
}
.item-row { display: flex; justify-content: space-between; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); }

#bottom-menu-container {
position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
display: flex; flex-direction: column; align-items: center; gap: 15px;
z-index: 500;
}
#main-action-menu {
background: var(--bg-dark); border: 1px solid var(--primary);
padding: 15px; border-radius: 15px; display: none;
backdrop-filter: blur(10px); box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
grid-template-columns: repeat(3, 1fr); gap: 10px;
}
.square-btn {
width: 50px; height: 50px; background: rgba(255,255,255,0.1);
border: 1px solid rgba(255,255,255,0.2); border-radius: 10px;
cursor: pointer; display: flex; align-items: center; justify-content: center;
font-size: 24px; transition: all 0.2s;
position: relative;
}
.square-btn:hover { background: var(--primary); transform: scale(1.05); }

.point-notify {
position: absolute; top: -5px; right: -5px;
background: #e74c3c; color: white; border-radius: 50%;
width: 18px; height: 18px; font-size: 10px;
display: none; align-items: center; justify-content: center;
border: 2px solid #111;
}

#btn-open-menu {
width: 60px; height: 60px; background: var(--primary);
border: 4px solid rgba(0,0,0,0.2); border-radius: 50%;
cursor: pointer; font-size: 28px; display: flex; align-items: center;
justify-content: center; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
z-index: 501;
}

#btn-repair-hive {
position: absolute; bottom: 180px; right: 40px;
width: 70px; height: 70px; background: #2ecc71;
border: 4px solid rgba(255,255,255,0.3); border-radius: 50%;
cursor: pointer; font-size: 30px; display: none; align-items: center;
justify-content: center; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
z-index: 600; transition: transform 0.1s;
}
#btn-repair-hive:active { transform: scale(0.9); }

#death-modal, #game-over-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
.modal-title { color: #e74c3c; font-size: 48px; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 5px; text-align: center; }

#chat-wrapper { 
position: absolute; bottom: 220px; left: -240px; width: 240px; z-index: 500; 
display: none; flex-direction: column; transition: left 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
}
#chat-display { height: 160px; background: var(--bg-dark); border-radius: 0 12px 0 0; padding: 12px; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; border: 1px solid var(--border); backdrop-filter: blur(15px); font-size: 13px; }
#chat-input-area { display: flex; background: rgba(30, 30, 30, 0.95); padding: 8px; border-radius: 0 0 12px 0; border: 1px solid var(--border); }
#chat-input { flex: 1; background: transparent; border: none; color: white; padding: 4px; font-size: 14px; outline: none; }

#btn-minimize-chat { 
position: absolute; right: -45px; bottom: 0; 
background: var(--primary); color: #111; 
border: none; border-radius: 0 8px 8px 0; cursor: pointer; 
width: 45px; height: 45px; 
font-size: 20px; font-weight: bold; 
box-shadow: 4px 0 10px rgba(0,0,0,0.3); 
transition: background 0.3s;
}

@keyframes pulse {
0% { transform: scale(1); box-shadow: 4px 0 10px rgba(0,0,0,0.3); }
50% { transform: scale(1.1); box-shadow: 0 0 20px var(--primary); background: #fff176; }
100% { transform: scale(1); box-shadow: 4px 0 10px rgba(0,0,0,0.3); }
}
.unread-pulse { animation: pulse 1.5s infinite ease-in-out !important; z-index: 502; }

#progression-modal {
position: fixed; top: 0; left: 0; width: 100%; height: 100%;
background: rgba(0,0,0,0.9); z-index: 2000;
display: none; flex-direction: column; align-items: center; padding: 20px;
backdrop-filter: blur(10px); overflow-y: auto;
}
.progression-container {
width: 100%; max-width: 800px;
background: var(--bg-dark); border: 2px solid var(--primary);
border-radius: 20px; padding: 20px; box-shadow: 0 0 30px rgba(241, 196, 15, 0.2);
}
.progression-header {
display: flex; justify-content: space-between; align-items: center;
border-bottom: 1px solid var(--border); padding-bottom: 15px; margin-bottom: 20px;
}
.points-badge {
background: var(--primary); color: #000; padding: 5px 15px;
border-radius: 20px; font-weight: bold; font-size: 14px;
}
.progression-grid {
display: grid; grid-template-columns: 1fr 1fr; gap: 20px;
}
@media (max-width: 600px) { .progression-grid { grid-template-columns: 1fr; } }

/* MOBILE ADJUSTMENTS */
@media (max-width: 600px) { 
    .progression-grid { grid-template-columns: 1fr; } 
    .menu-card { padding: 30px 15px; width: 95%; }
    .title-box { gap: 5px; }
    .menu-card h1 { font-size: 1.4rem; }
    .bee-flank { width: 35px; height: 35px; }
    .crown-g::before { font-size: 1.4rem; top: -18px; right: -6px; }
    .button-row { gap: 10px; }
    .main-btn { font-size: 0.8rem; padding: 14px 5px; }
    
    /* Ajustando XP HUD para n√£o sobrepor o Rel√≥gio no mobile */
    #lvl-hud { 
        min-width: 120px; 
        padding: 6px 15px; 
    }
    #lvl-text { font-size: 12px; }
    #xp-bar-container { height: 6px; }
    #time-hud { 
        padding: 4px 10px; 
        font-size: 10px; 
    }
}

.attr-card, .skill-card {
background: rgba(255,255,255,0.03); border: 1px solid var(--border);
border-radius: 12px; padding: 15px;
}
.attr-row {
display: flex; justify-content: space-between; align-items: center;
margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;
}
.attr-info { display: flex; flex-direction: column; }
.attr-name { font-weight: bold; color: var(--primary); font-size: 14px; }
.attr-val { font-size: 18px; font-family: monospace; }
.btn-plus {
width: 32px; height: 32px; background: var(--primary); border: none;
border-radius: 50%; cursor: pointer; font-weight: bold; font-size: 20px;
}
.btn-plus:disabled { opacity: 0.2; cursor: default; }

.skill-tree {
display: flex; flex-direction: column; gap: 10px;
}
.skill-item {
display: flex; align-items: center; gap: 15px;
padding: 12px; background: rgba(255,255,255,0.05); border-radius: 10px;
transition: all 0.2s; border: 1px solid transparent;
}
.skill-item.unlocked { border-color: var(--primary); background: rgba(241, 196, 15, 0.1); }
.skill-icon { font-size: 24px; width: 40px; text-align: center; }
.skill-desc { flex: 1; font-size: 12px; color: #ccc; }
.btn-unlock {
padding: 6px 12px; background: var(--secondary); border: none;
border-radius: 6px; color: white; cursor: pointer; font-size: 11px;
}
.btn-unlock:disabled { background: #555; opacity: 0.5; }

#loading-screen {
position: fixed; top: 0; left: 0; width: 100%; height: 100%;
background: radial-gradient(circle at center, #111 0%, #000 100%);
z-index: 4000;
display: none;
flex-direction: column; align-items: center; justify-content: center;
}

#loading-scene {
width: 80%; max-width: 600px;
height: 100px;
position: relative;
margin-bottom: 20px;
}

#loading-bar-track {
position: absolute; bottom: 0; left: 0;
width: 100%; height: 16px;
background: rgba(255,255,255,0.1);
border: 2px solid var(--primary);
border-radius: 8px;
overflow: hidden;
}

#loading-bar-active-fill {
width: 0%; height: 100%;
background: linear-gradient(90deg, var(--primary), var(--primary-dark));
box-shadow: 0 0 10px var(--primary);
}

#loading-ant {
position: absolute; bottom: 16px;
left: 0; transform: translateX(-50%);
font-size: 30px;
transition: left 0.1s linear;
}

#loading-bee-container {
position: absolute; bottom: 30px;
left: -10%;
width: 50px; height: 50px;
transform: translateX(-50%);
transition: left 0.1s linear, transform 0.3s;
}

#loading-bee-img {
width: 100%; height: 100%;
image-rendering: pixelated;
animation: flightBob 0.5s infinite alternate;
}

@keyframes flightBob { from { transform: translateY(0); } to { transform: translateY(-5px); } }

.muzzle-flash {
position: absolute; right: -10px; top: 25px;
width: 10px; height: 10px;
background: #ffeb3b;
border-radius: 50%;
opacity: 0;
box-shadow: 0 0 10px #ffeb3b;
animation: shootFlash 0.3s infinite;
}

@keyframes shootFlash { 0% { opacity: 0; } 50% { opacity: 1; transform: scale(1.5); } 100% { opacity: 0; } }

#loading-cookie {
position: absolute; bottom: 30px; right: 30px;
font-size: 40px;
animation: spinCookie 2s linear infinite;
}

@keyframes spinCookie { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

.explosion-text { font-size: 40px !important; animation: explodeScale 0.5s ease-out forwards; }
@keyframes explodeScale { 0% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.5); } 100% { transform: translateX(-50%) scale(0); opacity: 0; } }

#menu { 
position: fixed; top: 0; left: 0; width: 100%; height: 100%;
display: flex; flex-direction: column; align-items: center; justify-content: center;
background: radial-gradient(circle at center, #2c2504 0%, #000000 100%);
z-index: 3000; padding: 20px; box-sizing: border-box;
overflow: hidden;
}

.hex-bg {
position: absolute; top: 0; left: 0; width: 100%; height: 100%;
background-image: 
radial-gradient(var(--royal-gold) 1px, transparent 1px);
background-size: 40px 40px;
opacity: 0.05;
pointer-events: none;
animation: panBg 60s linear infinite;
}

@keyframes panBg { from { background-position: 0 0; } to { background-position: 40px 40px; } }

.pollen-particle {
position: absolute; background: var(--primary);
border-radius: 50%; opacity: 0.6;
animation: floatUp linear infinite;
}

@keyframes floatUp {
0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
50% { opacity: 0.8; }
100% { transform: translateY(-10vh) scale(1.2); opacity: 0; }
}

.menu-card {
position: relative;
background: rgba(10, 10, 10, 0.9);
border: 2px solid var(--royal-gold);
border-radius: 16px;
padding: 40px 30px;
width: 100%; max-width: 500px;
box-shadow: 0 0 30px rgba(241, 196, 15, 0.15), inset 0 0 50px rgba(0,0,0,0.8);
text-align: center;
backdrop-filter: blur(10px);
z-index: 10;
}

.title-box {
display: flex;
align-items: center;
justify-content: center;
gap: 15px;
margin-bottom: 10px;
padding-bottom: 15px;
border-bottom: 1px solid rgba(241, 196, 15, 0.3);
}

.bee-flank {
width: 50px; height: 50px;
animation: swayBee 2s infinite ease-in-out alternate;
image-rendering: pixelated;
flex-shrink: 0;
}

.bee-left { animation-delay: 0s; }
.bee-right { animation-delay: 1s; }

@keyframes swayBee {
from { transform: translateY(0) rotate(-10deg); }
to { transform: translateY(-8px) rotate(10deg); }
}

.menu-card h1 {
font-family: 'Times New Roman', serif;
font-size: 2.2rem; margin: 0;
color: var(--royal-gold);
text-shadow: 0 2px 10px rgba(241, 196, 15, 0.4);
text-transform: uppercase;
letter-spacing: 2px;
white-space: nowrap;
}

.crown-g {
position: relative;
display: inline-block;
}

.crown-g::before {
content: 'üëë';
position: absolute;
top: -28px;
right: -20px;
font-size: 2rem;
transform: rotate(25deg);
filter: drop-shadow(0 2px 2px rgba(0,0,0,0.8));
pointer-events: none;
}

.update-badge {
display: inline-block;
background: linear-gradient(45deg, #b7950b, #f1c40f);
color: #000;
padding: 6px 14px;
border-radius: 20px;
font-size: 0.8rem;
font-weight: bold;
text-transform: uppercase;
margin-bottom: 25px;
box-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
animation: glowBadge 2s infinite alternate;
}

@keyframes glowBadge { from { box-shadow: 0 0 5px var(--primary); } to { box-shadow: 0 0 15px var(--primary); } }

.menu-input {
width: 100%; padding: 15px;
background: rgba(0, 0, 0, 0.6);
border: 1px solid #444;
border-left: 3px solid var(--primary-dark);
border-radius: 4px;
color: #e0e0e0; font-size: 1rem;
margin-bottom: 5px;
box-sizing: border-box;
transition: all 0.3s;
font-family: monospace;
user-select: text;
-webkit-user-select: text;
}

.menu-input:focus {
outline: none;
border-color: var(--royal-gold);
background: rgba(20, 20, 20, 0.9);
box-shadow: 0 0 15px rgba(241, 196, 15, 0.1);
}

.input-group label {
display: block; text-align: left;
color: #aaa; font-size: 0.75rem;
text-transform: uppercase;
margin-bottom: 6px; margin-top: 15px;
letter-spacing: 1px;
}

.button-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 25px; }

.main-btn {
padding: 16px; cursor: pointer; border-radius: 6px; border: none;
font-weight: 800; font-size: 0.95rem; text-transform: uppercase;
letter-spacing: 1px; transition: all 0.2s;
display: flex; align-items: center; justify-content: center; gap: 8px;
font-family: 'Segoe UI', sans-serif;
position: relative; overflow: hidden;
}

.main-btn::after {
content: ''; position: absolute; top: -50%; left: -50%;
width: 200%; height: 200%;
background: linear-gradient(to bottom right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 100%);
transform: rotate(45deg) translateY(-100%);
transition: transform 0.5s;
}
.main-btn:hover::after { transform: rotate(45deg) translateY(0%); }

.btn-create { 
background: linear-gradient(to bottom, #f1c40f, #d4ac0d); 
color: #121212; border: 1px solid #f39c12;
}
.btn-join { 
background: linear-gradient(to bottom, #3498db, #2980b9); 
color: white; border: 1px solid #2980b9;
}

#studio-footer { 
position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
text-align: center; pointer-events: none; z-index: 10;
opacity: 0.7; font-size: 0.8rem;
white-space: nowrap;
}

@media (max-width: 600px) {
.menu-card { padding: 30px 15px; width: 95%; }
.title-box { gap: 5px; }
.menu-card h1 { font-size: 1.4rem; }
.bee-flank { width: 35px; height: 35px; }
.crown-g::before { font-size: 1.4rem; top: -18px; right: -6px; }
.button-row { gap: 10px; }
.main-btn { font-size: 0.8rem; padding: 14px 5px; }
}

.joy-container { position: absolute; bottom: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; display: none; border: 2px solid rgba(255,255,255,0.2); z-index: 150; }
#move-base { left: 40px; }
#aim-base { right: 40px; border-color: rgba(255, 71, 87, 0.3); }
.joy-stick { position: absolute; width: 50px; height: 50px; border-radius: 50%; top: 35px; left: 35px; pointer-events: none; opacity: 0.8; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
</style>
</head>
<body>

<div id="time-hud">‚òÄÔ∏è Dia 1 ‚Ä¢ 08:00</div>

<div id="central-hud">
<div id="lvl-hud">
<div id="lvl-text">N√≠vel 1</div>
<div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
</div>
<div id="time-hud">‚òÄÔ∏è Dia 1 ‚Ä¢ 08:00</div>
<div id="coords">X: 1100 Y: 1100</div>
<div id="horde-hud"></div>
</div>

<div id="sidebar-container">
<div id="session-panel" class="side-panel">
<button id="btn-session-toggle" class="panel-toggle">üë•</button>
<div class="panel-content">
<div class="panel-title">Sess√£o Ativa</div>
<div id="player-items-container"></div>
</div>
</div>

<div id="hive-panel" class="side-panel">
<button id="btn-hive-toggle" class="panel-toggle">üè†</button>
<div class="panel-content">
<div class="panel-title">Colmeias Ativas</div>
<div id="hive-items-container"></div>
</div>
</div>
</div>

<div id="bottom-menu-container">
<div id="main-action-menu">
<button class="square-btn" id="btn-progression" title="Evolu√ß√£o">
üêù <div class="point-notify" id="attr-notify">!</div>
</button>
<button class="square-btn" id="btn-manual-save" title="Salvar Reino">üíæ</button>
<button class="square-btn" style="opacity: 0.3;">üéí</button>
</div>
<button id="btn-open-menu">‚ò∞</button>
</div>

<div id="progression-modal">
<div class="progression-container">
<div class="progression-header">
<h2 style="margin:0; color:var(--primary)">EVOLU√á√ÉO REAL</h2>
<div class="points-badge">Pontos: <span id="stat-points">0</span></div>
<button class="main-btn btn-join" onclick="toggleProgression()" style="padding: 10px 20px; font-size: 12px;">FECHAR</button>
</div>

<div class="progression-grid">
<div class="attr-card">
<h3 style="margin-top:0">Atributos B√°sicos</h3>
<div class="attr-row">
<div class="attr-info">
<span class="attr-name">üí™ FOR√áA</span>
<small>Dano de ataque</small>
</div>
<div style="display:flex; align-items:center; gap:10px">
<span class="attr-val" id="val-str">0</span>
<button class="btn-plus" onclick="upgradeStat('str')">+</button>
</div>
</div>
<div class="attr-row">
<div class="attr-info">
<span class="attr-name">‚ö° AGILIDADE</span>
<small>Velocidade de movimento</small>
</div>
<div style="display:flex; align-items:center; gap:10px">
<span class="attr-val" id="val-agi">0</span>
<button class="btn-plus" onclick="upgradeStat('agi')">+</button>
</div>
</div>
<div class="attr-row">
<div class="attr-info">
<span class="attr-name">‚ù§Ô∏è VITALIDADE</span>
<small>Vida m√°xima (+HP)</small>
</div>
<div style="display:flex; align-items:center; gap:10px">
<span class="attr-val" id="val-vit">0</span>
<button class="btn-plus" onclick="upgradeStat('vit')">+</button>
</div>
</div>
</div>

<div class="skill-card">
<h3 style="margin-top:0">√Årvore Real</h3>
<div class="skill-tree">
<div class="skill-item" id="skill-double">
<div class="skill-icon">üèπ</div>
<div class="skill-desc">
<strong>Disparo Duplo</strong><br>Chance de atirar 2 proj√©teis.
</div>
<button class="btn-unlock" onclick="unlockSkill('double')">2 pts</button>
</div>
<div class="skill-item" id="skill-regen">
<div class="skill-icon">üåø</div>
<div class="skill-desc">
<strong>Regenera√ß√£o</strong><br>Recupera HP lentamente.
</div>
<button class="btn-unlock" onclick="unlockSkill('regen')">3 pts</button>
</div>
<div class="skill-item" id="skill-pollen">
<div class="skill-icon">‚ú®</div>
<div class="skill-desc">
<strong>P√≥len Magn√©tico</strong><br>Coleta p√≥len mais r√°pido.
</div>
<button class="btn-unlock" onclick="unlockSkill('pollen')">2 pts</button>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="death-modal">
<h2 class="modal-title">Derrotado</h2>
<button class="main-btn btn-create" onclick="respawnPlayer()" style="width: 200px;">RESPAWN</button>
</div>
<div id="game-over-modal">
<h2 class="modal-title">COLMEIA DESTRU√çDA</h2>
<button class="main-btn btn-create" onclick="location.reload()" style="width: 200px;">RECOME√áAR</button>
</div>

<div id="chat-wrapper">
<button id="btn-minimize-chat">üí¨</button>
<div id="chat-display"></div>
<div id="chat-input-area">
<input type="text" id="chat-input" placeholder="Falar..." autocomplete="off">
</div>
</div>

<div id="loading-screen">
<div id="loading-scene">
<div id="loading-bee-container">
<div class="muzzle-flash"></div>
<img src="BeeRightIdle.png" id="loading-bee-img">
</div>
<div id="loading-ant">üêú</div>
<div id="loading-bar-track">
<div id="loading-bar-active-fill"></div>
</div>
</div>
<h3 style="color:var(--primary); letter-spacing: 2px; text-transform: uppercase;">Carregando Mundo...</h3>
<div id="loading-cookie">üç™</div>
</div>

<div id="menu">
<div class="hex-bg"></div>
<div class="menu-card">
<div class="title-box">
<img src="BeeLeftIdle.png" class="bee-flank bee-left">
<h1>The Hive Kin<span class="crown-g">g</span>dom</h1>
<img src="BeeRightIdle.png" class="bee-flank bee-right">
</div>
<div class="update-badge">Update: Pollen War ‚Ä¢ v1.4</div>
<div class="input-group">
<label>Identidade do Guerreiro</label>
<input type="text" id="player-nick" class="menu-input" placeholder="Seu apelido..." maxlength="12">
</div>
<div class="input-group">
<label>Nome do Reino (ID da Sala)</label>
<input type="text" id="room-code" class="menu-input" placeholder="Ex: KING1" maxlength="12">
</div>
<div class="input-group">
<label>Chave do Reino (Senha)</label>
<input type="password" id="room-pass" class="menu-input" placeholder="Senha secreta..." maxlength="10">
</div>
<div class="button-row">
<button class="main-btn btn-create" onclick="startSession(true)">
<span>üëë</span> Criar Reino
</button>
<button class="main-btn btn-join" onclick="startSession(false)">
<span>‚öîÔ∏è</span> Entrar
</button>
</div>
<div style="margin-top: 20px; font-size: 0.8rem; color: #666; font-style: italic;">
"Proteja a Rainha. Colete o Ouro. Sobreviva."
</div>
</div>
<div id="studio-footer">FUNüç™COOK STUDIO &copy; 2025</div>
</div>

<button id="btn-repair-hive">üõ†Ô∏è</button>

<div id="move-base" class="joy-container"><div id="move-stick" class="joy-stick" style="background:var(--primary)"></div></div>
<div id="aim-base" class="joy-container"><div id="aim-stick" class="joy-stick" style="background:#ff4757"></div></div>

<canvas id="gameCanvas"></canvas>

<script>
document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
document.addEventListener('gesturechange', function(e) { e.preventDefault(); }); 
document.addEventListener('gestureend', function(e) { e.preventDefault(); });

function createMenuParticles() {
const menu = document.getElementById('menu');
for(let i=0; i<30; i++) {
const p = document.createElement('div');
p.classList.add('pollen-particle');
p.style.left = Math.random() * 100 + '%';
p.style.width = (Math.random() * 4 + 2) + 'px';
p.style.height = p.style.width;
p.style.animationDuration = (Math.random() * 5 + 5) + 's';
p.style.animationDelay = (Math.random() * 5) + 's';
menu.appendChild(p);
}
}
createMenuParticles();

window.onload = function() {
if(localStorage.getItem('hive_nick')) document.getElementById('player-nick').value = localStorage.getItem('hive_nick');
if(localStorage.getItem('hive_room')) document.getElementById('room-code').value = localStorage.getItem('hive_room');
if(localStorage.getItem('hive_pass')) document.getElementById('room-pass').value = localStorage.getItem('hive_pass');
};

function startLoadingSequence() {
document.getElementById('menu').style.display = 'none';
const loadingScreen = document.getElementById('loading-screen');
loadingScreen.style.display = 'flex';

const bar = document.getElementById('loading-bar-active-fill');
const ant = document.getElementById('loading-ant');
const beeCont = document.getElementById('loading-bee-container');
const beeImg = document.getElementById('loading-bee-img');
const muzzle = document.querySelector('.muzzle-flash');

const duration = 5000; 
const startTime = Date.now();
let exploded = false;

function frame() {
const now = Date.now();
const elapsed = now - startTime;
let pct = Math.min(1, elapsed / duration);
const pctVal = pct * 100;

if (pct < 1) {
bar.style.width = pctVal + '%';
ant.style.left = pctVal + '%';
let beePos = Math.max(0, pctVal - 1); 
beeCont.style.left = beePos + '%';
requestAnimationFrame(frame);
} else {
if(!exploded) {
exploded = true;
bar.style.width = '100%';
ant.innerText = "üí•";
ant.classList.add('explosion-text');
muzzle.style.display = 'none';
beeImg.src = 'BeeDownIdle.png';
beeImg.style.animation = 'none'; 
beeCont.style.transition = 'left 0.5s ease-out';
beeCont.style.left = '50%';

setTimeout(() => {
loadingScreen.style.display = 'none';
if(isHost) { 
const hasSave = loadGameProgress(); 
if(!hasSave) generateFlowers(currentRoomCode); 
startGame(); 
} else { 
startGame(); 
}
}, 1000);
}
}
}
requestAnimationFrame(frame);
}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const chatInput = document.getElementById('chat-input');
const chatWrapper = document.getElementById('chat-wrapper');
const chatMinimizeBtn = document.getElementById('btn-minimize-chat');
const sessionPanel = document.getElementById('session-panel');
const hivePanel = document.getElementById('hive-panel');
const deathModal = document.getElementById('death-modal');
const gameOverModal = document.getElementById('game-over-modal');
const moveBase = document.getElementById('move-base');
const aimBase = document.getElementById('aim-base');
const moveStick = document.getElementById('move-stick');
const aimStick = document.getElementById('aim-stick');
const playerItemsContainer = document.getElementById('player-items-container');
const hiveItemsContainer = document.getElementById('hive-items-container');
const btnOpenMenu = document.getElementById('btn-open-menu');
const mainActionMenu = document.getElementById('main-action-menu');
const btnRepairHive = document.getElementById('btn-repair-hive');
const btnManualSave = document.getElementById('btn-manual-save');

const assets = { 
bee: { 
Down: new Image(), Left: new Image(), Up: new Image(), Right: new Image(),
DownIdle: new Image(), LeftIdle: new Image(), UpIdle: new Image(), RightIdle: new Image()
}, 
ground: new Image() 
};
assets.bee.Down.src = 'BeeDown.png'; 
assets.bee.Left.src = 'BeeLeft.png'; 
assets.bee.Up.src = 'BeeUp.png'; 
assets.bee.Right.src = 'BeeRight.png';
assets.bee.DownIdle.src = 'BeeDownIdle.png'; 
assets.bee.LeftIdle.src = 'BeeLeftIdle.png'; 
assets.bee.UpIdle.src = 'BeeUpIdle.png'; 
assets.bee.RightIdle.src = 'BeeRightIdle.png';
assets.ground.src = 'Grass.png';

let isHost = false;
let hostPassword = ""; 
let hive = { x: 1000, y: 1000, hp: 500, maxHp: 500, destroyed: false };
let currentRoomCode = "";
let lastAutoSaveTime = Date.now();

let dayCycle = {
time: 480, 
day: 1,
speed: 1.5, 
isNight: false,
overlayAlpha: 0
};

let players = { 
me: { 
x: 1100, y: 1100, dir: 'Down', nick: "", color: "#f1c40f", 
hp: 100, maxHp: 100, isDead: false, pollen: 0, 
lvl: 1, xp: 0, nextXp: 100, isCollecting: false,
moving: false, 
statPoints: 0,
stats: { str: 0, agi: 0, vit: 0 },
skills: { double: false, regen: false, pollen: false },
aimAngle: 0
}, 
peer: { 
x: 1100, y: 1100, tX: 1100, tY: 1100, dir: 'Down', nick: "Amigo", color: "#3498db", 
active: false, hp: 100, maxHp: 100, isDead: false, pollen: 0, lvl: 1, lastSeen: 0, 
isCollecting: false, moving: false, authorized: false 
} 
};

let projectiles = [], enemies = [], flowers = [], particles = []; 
let camera = { x: 0, y: 0 }, peer, conn, keys = {};
const TILE_SIZE = 64;
let lastNetUpdate = 0, lastShootTime = 0, lastEnemySpawnTime = 0, lastHeartbeat = 0;
let mousePos = { x: 0, y: 0 }, isMouseDown = false;
let touchIds = { move: null, aim: null }, joyMove = { dx: 0, dy: 0 }, joyAim = { angle: 0, active: false };

let isWaveActive = false;
let enemiesSpawnedInWave = 0;
let enemiesKilledInWave = 0;
let wavePrepTimer = 0; 
let isWavePrepActive = false;

function seededRandom(seed) {
let value = seed;
return function() {
value = (value * 16807) % 2147483647;
return (value - 1) / 2147483646;
};
}

function stringToSeed(str) {
let hash = 0;
for (let i = 0; i < str.length; i++) hash = ((hash << 5) - hash) + str.charCodeAt(i) | 0;
return Math.abs(hash);
}

function saveGameProgress(isManual = false) {
if (!isHost) return;

const saveData = {
seed: currentRoomCode,
hive: hive,
dayCycle: { time: dayCycle.time, day: dayCycle.day },
flowers: flowers.map(f => ({
id: f.id, 
cooldown: f.cooldown, 
growState: f.growState,
plantTime: f.plantTime
})),
wave: {
isActive: isWaveActive,
enemiesSpawned: enemiesSpawnedInWave,
enemiesKilled: enemiesKilledInWave,
prepTimer: wavePrepTimer,
isPrepActive: isWavePrepActive
},
hostPlayer: {
lvl: players.me.lvl,
xp: players.me.xp,
statPoints: players.me.statPoints,
stats: players.me.stats,
skills: players.me.skills,
x: players.me.x,
y: players.me.y,
pollen: players.me.pollen
},
peerPlayer: players.peer.active ? {
nick: players.peer.nick,
lvl: players.peer.lvl,
pollen: players.peer.pollen,
hp: players.peer.hp
} : (localStorage.getItem(`hive_save_peer_${currentRoomCode}`) ? JSON.parse(localStorage.getItem(`hive_save_peer_${currentRoomCode}`)) : null),
timestamp: Date.now()
};

localStorage.setItem(`hive_save_world_${currentRoomCode}`, JSON.stringify(saveData));
if (players.peer.active) {
localStorage.setItem(`hive_save_peer_${currentRoomCode}`, JSON.stringify(saveData.peerPlayer));
}

if (isManual) {
addMsg("SISTEMA", "Reino e Mapa salvos com sucesso!", "msg-sys");
createParticles(players.me.x, players.me.y, "#2ecc71", 15);
}
}

function loadGameProgress() {
const rawSave = localStorage.getItem(`hive_save_world_${currentRoomCode}`);
if (!rawSave) return false;

try {
const save = JSON.parse(rawSave);
hive = save.hive;
if(save.dayCycle) { dayCycle.time = save.dayCycle.time; dayCycle.day = save.dayCycle.day; }

generateFlowers(save.seed || currentRoomCode);
save.flowers.forEach(savedFlower => {
let f = flowers.find(fl => fl.id === savedFlower.id);
if(f) {
f.cooldown = savedFlower.cooldown;
f.growState = savedFlower.growState;
f.plantTime = savedFlower.plantTime;
}
});

isWaveActive = save.wave.isActive;
enemiesSpawnedInWave = save.wave.enemiesSpawned;
enemiesKilledInWave = save.wave.enemiesKilled || 0;
wavePrepTimer = save.wave.prepTimer || 0;
isWavePrepActive = save.wave.isPrepActive || false;

players.me.lvl = save.hostPlayer.lvl;
players.me.xp = save.hostPlayer.xp;
players.me.pollen = save.hostPlayer.pollen || 0;
players.me.statPoints = save.hostPlayer.statPoints;
players.me.stats = save.hostPlayer.stats;
players.me.skills = save.hostPlayer.skills;
players.me.x = save.hostPlayer.x;
players.me.y = save.hostPlayer.y;

players.me.nextXp = Math.floor(100 * Math.pow(1.2, players.me.lvl));
players.me.maxHp = 100 + (players.me.stats.vit * 20);
players.me.hp = players.me.maxHp;

updateXpHud();
updateProgressionUI();
addMsg("SISTEMA", "Reino restaurado.", "msg-sys");
return true;
} catch (e) {
console.error("Erro ao carregar save:", e);
return false;
}
}

function generateFlowers(seedStr) {
flowers = [];
const seed = stringToSeed(seedStr);
const rng = seededRandom(seed);
const types = ["üå∏", "üåª", "üå∑"];

const gridSize = 400; 
const range = 2400;   

for(let gx = -range; gx < range; gx += gridSize) {
for(let gy = -range; gy < range; gy += gridSize) {
if(rng() > 0.4) {
const fx = gx + (rng() * gridSize);
const fy = gy + (rng() * gridSize);

if(Math.hypot(fx - hive.x, fy - hive.y) < 200) continue;

flowers.push({
id: flowers.length,
x: fx, 
y: fy,
emoji: types[Math.floor(rng() * types.length)],
cooldown: 0, 
maxCooldown: 300, 
phase: rng() * Math.PI * 2,
growState: 'mature', 
plantTime: 0
});
}
}
}
}

btnManualSave.onclick = () => saveGameProgress(true);

btnOpenMenu.onclick = () => {
const isVisible = mainActionMenu.style.display === 'grid';
mainActionMenu.style.display = isVisible ? 'none' : 'grid';
btnOpenMenu.innerHTML = isVisible ? '‚ò∞' : '‚úï';
};

function toggleProgression() {
const modal = document.getElementById('progression-modal');
const isVisible = modal.style.display === 'flex';
modal.style.display = isVisible ? 'none' : 'flex';
if(!isVisible) updateProgressionUI();
}

document.getElementById('btn-progression').onclick = toggleProgression;

function updateProgressionUI() {
document.getElementById('stat-points').innerText = players.me.statPoints;
document.getElementById('val-str').innerText = players.me.stats.str;
document.getElementById('val-agi').innerText = players.me.stats.agi;
document.getElementById('val-vit').innerText = players.me.stats.vit;
document.getElementById('attr-notify').style.display = players.me.statPoints > 0 ? 'flex' : 'none';
const btns = document.querySelectorAll('.btn-plus');
btns.forEach(b => b.disabled = players.me.statPoints <= 0);
updateSkillUI('double', 2);
updateSkillUI('regen', 3);
updateSkillUI('pollen', 2);
}

function updateSkillUI(id, cost) {
const item = document.getElementById('skill-' + id);
const btn = item.querySelector('.btn-unlock');
if(players.me.skills[id]) {
item.classList.add('unlocked');
btn.innerText = "LIBERADO";
btn.disabled = true;
} else {
btn.disabled = players.me.statPoints < cost;
}
}

function upgradeStat(type) {
if(players.me.statPoints > 0) {
players.me.stats[type]++;
players.me.statPoints--;
if(type === 'vit') {
players.me.maxHp = 100 + (players.me.stats.vit * 20);
players.me.hp += 20;
}
updateProgressionUI();
saveGameProgress(); 
}
}

function unlockSkill(id) {
const costs = { double: 2, regen: 3, pollen: 2 };
const cost = costs[id];
if(players.me.statPoints >= cost && !players.me.skills[id]) {
players.me.skills[id] = true;
players.me.statPoints -= cost;
updateProgressionUI();
addMsg("SISTEMA", "Habilidade " + id + " desbloqueada!", "msg-sys");
saveGameProgress(); 
}
}

function toggleChat() {
let currentLeft = window.getComputedStyle(chatWrapper).getPropertyValue('left');
let isHidden = currentLeft.includes('-') || currentLeft === 'auto';
chatWrapper.style.left = isHidden ? "0px" : "-240px";
chatMinimizeBtn.innerHTML = isHidden ? "¬´" : "üí¨";
if (isHidden) chatMinimizeBtn.classList.remove('unread-pulse');
}

chatMinimizeBtn.onclick = toggleChat;
chatMinimizeBtn.ontouchstart = (e) => { e.preventDefault(); toggleChat(); };

document.getElementById('btn-session-toggle').onclick = () => {
sessionPanel.classList.toggle('active');
document.getElementById('btn-session-toggle').innerHTML = sessionPanel.classList.contains('active') ? "¬´" : "üë•";
};

document.getElementById('btn-hive-toggle').onclick = () => {
hivePanel.classList.toggle('active');
document.getElementById('btn-hive-toggle').innerHTML = hivePanel.classList.contains('active') ? "¬´" : "üè†";
};

function addXp(amount) {
if(players.me.isDead) return;
players.me.xp += amount;
if(players.me.xp >= players.me.nextXp) {
players.me.xp -= players.me.nextXp;
players.me.lvl++;
players.me.statPoints += 2;
players.me.nextXp = Math.floor(100 * Math.pow(1.2, players.me.lvl));
addMsg("SISTEMA", `LEVEL UP! N√≠vel ${players.me.lvl}! (+2 pontos)`, "msg-sys");
createParticles(players.me.x, players.me.y, "#f1c40f", 20, 'pixel');
updateProgressionUI();
saveGameProgress(); 
}
updateXpHud();
}

function updateXpHud() {
const perc = (players.me.xp / players.me.nextXp) * 100;
document.getElementById('xp-bar-fill').style.width = perc + "%";
document.getElementById('lvl-text').innerText = `N√≠vel ${players.me.lvl}`;
}

function createParticles(x, y, color, count, type = 'pixel') {
for(let i=0; i<count; i++) {
let vx = (Math.random() - 0.5) * 4;
let vy = (Math.random() - 0.5) * 4;
let life = 1.0;
let decay = Math.random() * 0.02 + 0.01;
if(type === 'pollen') { vx = (Math.random() - 0.5) * 1.5; vy = Math.random() * 1.5; decay = 0.015 + Math.random() * 0.015; }
else if (type === 'heart') { vx *= 0.5; vy = -Math.random(); decay = 0.01; }
particles.push({ x, y, vx, vy, life, decay, color, type });
}
}

window.addEventListener('mousemove', e => { mousePos.x = e.clientX; mousePos.y = e.clientY; });
window.addEventListener('mousedown', () => isMouseDown = true);
window.addEventListener('mouseup', () => isMouseDown = false);
window.addEventListener('keydown', e => {
if(document.activeElement === chatInput) { if(e.key === 'Enter') { e.preventDefault(); sendMsg(); } return; }
if(e.key === 'Enter') { e.preventDefault(); chatInput.focus(); }
keys[e.code] = true;
});
window.addEventListener('keyup', e => keys[e.code] = false);

function startSession(host) {
const code = document.getElementById('room-code').value.trim();
const nick = document.getElementById('player-nick').value.trim();
const pass = document.getElementById('room-pass').value.trim();
if(!nick || !code || !pass) return alert("Preencha o Nick, o Nome do Reino e a Senha!");

localStorage.setItem('hive_nick', nick);
localStorage.setItem('hive_room', code);
localStorage.setItem('hive_pass', pass);

isHost = host;
hostPassword = pass;
currentRoomCode = code;
players.me.nick = nick;
players.me.color = host ? "#f1c40f" : "#3498db";
players.peer.color = host ? "#3498db" : "#f1c40f";

if(peer && !peer.destroyed) peer.destroy();

// CORRE√á√ÉO DA ARQUITETURA P2P:
// Somente o HOST tenta pegar o ID fixo da sala.
// O GUEST entra com um ID aleat√≥rio (passando null) para evitar erro de conflito.
const peerId = host ? 'hive-game-' + code : null;
peer = new Peer(peerId);

peer.on('error', (err) => {
if(err.type === 'unavailable-id') alert("Este Nome de Reino j√° est√° em uso! Escolha outro.");
else if (err.type === 'peer-unavailable') alert("Reino n√£o encontrado! Verifique o nome.");
else alert("Erro na conex√£o: " + err.type);
});

peer.on('open', (id) => { 
if(host) { 
startLoadingSequence(); 
} else { 
// O Convidado se conecta ao ID fixo que o Host criou
conn = peer.connect('hive-game-' + code); 
setupConn(); 
} 
});

peer.on('connection', c => { conn = c; setupConn(); });
}

function setupConn() {
conn.on('open', () => { 
if(!isHost) conn.send({ type: 'auth', pass: document.getElementById('room-pass').value.trim(), nick: players.me.nick, color: players.me.color });
});
conn.on('data', data => {
if (isHost && data.type === 'auth') {
if (data.pass === hostPassword) {
const peerSave = localStorage.getItem(`hive_save_peer_${currentRoomCode}`);
if(peerSave) {
const pData = JSON.parse(peerSave);
if(pData.nick === data.nick) {
players.peer.lvl = pData.lvl;
players.peer.pollen = pData.pollen;
players.peer.hp = pData.hp;
}
}
players.peer.nick = data.nick; players.peer.color = data.color;
players.peer.authorized = true; players.peer.active = true;
players.peer.lastSeen = Date.now();
conn.send({ type: 'auth_success' });
conn.send({ type: 'init_flowers', data: flowers });
conn.send({ type: 'handshake', nick: players.me.nick, color: players.me.color });
addMsg("SISTEMA", `${data.nick} entrou no reino!`, "msg-sys");
} else {
conn.send({ type: 'auth_fail' });
setTimeout(() => { conn.close(); }, 500);
}
return;
}
if (!isHost) {
if (data.type === 'auth_success') { startLoadingSequence(); return; }
else if (data.type === 'auth_fail') { alert("SENHA INCORRETA!"); peer.destroy(); return; }
}
if (isHost && !players.peer.authorized) return;
if(data.type === 'chat') addMsg(players.peer.nick, data.msg, "peer");
else if(data.type === 'shoot') spawnProjectile(data.x, data.y, data.angle, false);
else if(data.type === 'handshake') { players.peer.nick = data.nick; players.peer.color = data.color; }
else if(data.type === 'reward_xp') { addXp(data.amount); }
else if(data.type === 'upd_pollen') { players.me.pollen = data.amount; }
else if(data.type === 'init_flowers') { flowers = data.data; }
else if(data.type === 'sync_flowers_list') { flowers = data.data; } 
else if(data.type === 'sync_flower_cd') { if(flowers[data.id]) flowers[data.id].cooldown = data.time; }
else if(data.type === 'fx') { 
if(data.effect === 'damage') createParticles(data.x, data.y, "#ff0000", 8);
if(data.effect === 'death') createParticles(data.x, data.y, "#000", 12);
if(data.effect === 'heart') createParticles(data.x, data.y, "#ff4d4d", 15, 'heart');
if(data.effect === 'pollen') createParticles(data.x, data.y, "#fffa65", 1, 'pollen');
}
else if(data.type === 'req_pollen') {
if(isHost && flowers[data.id] && flowers[data.id].growState === 'mature' && flowers[data.id].cooldown <= 0) {
flowers[data.id].cooldown = flowers[data.id].maxCooldown;
players.peer.pollen += 0.4;
conn.send({ type: 'upd_pollen', amount: players.peer.pollen });
conn.send({ type: 'sync_flower_cd', id: data.id, time: flowers[data.id].maxCooldown });
}
}
else if(data.type === 'wave_clear') { showWaveClearEffect(); }
else if(data.type === 'sync_world') { 
players.peer.lastSeen = Date.now();
enemies = data.enemies.map(enNew => { let ex = enemies.find(e => e.id === enNew.id); return ex ? {...enNew} : enNew; });
isWaveActive = data.isWaveActive; hive.hp = data.hiveHp; hive.destroyed = data.hiveDestroyed;
if(data.dayCycle) { dayCycle.time = data.dayCycle.time; dayCycle.day = data.dayCycle.day; }
wavePrepTimer = data.wavePrepTimer;
isWavePrepActive = data.isWavePrepActive;
}
else if(data.type === 'repair') { 
if(isHost) {
const amountPollen = data.pollen || 100;
const hpGain = (amountPollen / 100) * (hive.destroyed ? 25 : 50);
hive.hp = Math.min(hive.maxHp, hive.hp + hpGain);
if(hive.hp > 0) { 
if(hive.destroyed) saveGameProgress(); 
hive.destroyed = false; 
}
conn.send({ type: 'fx', effect: 'heart', x: hive.x, y: hive.y });
conn.send({ type: 'reward_xp', amount: Math.floor(amountPollen * 0.15) }); 
}
}
else if(data.type === 'hit') { if(!isHost && data.target === 'me') takeDamage(data.amount); }
else if(data.type === 'pos') { 
players.peer.lastSeen = Date.now(); players.peer.tX = data.x; players.peer.tY = data.y; 
players.peer.dir = data.dir; players.peer.hp = data.hp; players.peer.maxHp = data.maxHp; players.peer.isDead = data.isDead; 
players.peer.pollen = data.pollen; players.peer.lvl = data.lvl; players.peer.active = true;
players.peer.isCollecting = data.isCollecting;
players.peer.moving = data.moving; 
}
else if(data.type === 'ping') { if(!isHost) conn.send({type: 'pong'}); }
else if(data.type === 'pong') { players.peer.lastSeen = Date.now(); }
});
conn.on('close', () => { 
if(isHost) saveGameProgress(); 
players.peer.active = false; 
players.peer.authorized = false; 
addMsg("SISTEMA", "Conex√£o perdida.", "msg-sys"); 
});
}

function showWaveClearEffect() { addMsg("SISTEMA", "HORDA DESTRU√çDA! +3 Minutos de Paz.", "msg-sys"); createParticles(hive.x, hive.y, "#3498db", 30, 'pixel'); }

function takeDamage(amount) {
if(players.me.isDead) return;
players.me.hp -= amount;
createParticles(players.me.x, players.me.y, "#ff0000", 5);
if(players.me.hp <= 0) { players.me.hp = 0; players.me.isDead = true; deathModal.style.display = 'flex'; players.me.pollen = 0; }
}

function respawnPlayer() { players.me.x = 1100; players.me.y = 1100; players.me.hp = players.me.maxHp; players.me.isDead = false; deathModal.style.display = 'none'; }

function fire(angle) {
if(Date.now() - lastShootTime < 180 || players.me.isDead) return;
spawnProjectile(players.me.x, players.me.y, angle, true);
if(players.me.skills.double && Math.random() < 0.3) {
spawnProjectile(players.me.x, players.me.y, angle + 0.1, true);
}
if(players.peer.active && conn && conn.open) conn.send({ type: 'shoot', x: players.me.x, y: players.me.y, angle: angle });
lastShootTime = Date.now();
}

function spawnProjectile(x, y, angle, isMe) {
const bonusVel = isMe ? (players.me.stats.str * 0.5) : 0;
projectiles.push({ x, y, vx: Math.cos(angle)*(12+bonusVel), vy: Math.sin(angle)*(12+bonusVel), life: 60, color: isMe ? players.me.color : players.peer.color, owner: isMe ? 'me' : 'peer' });
}

function runWaveLogic() {
if (!isHost) { 
enemies.forEach(en => { en.x += en.vx; en.y += en.vy; }); 
return; 
}

if (Date.now() - lastHeartbeat > 3000) { 
if (conn && conn.open) conn.send({type: 'ping'}); 
lastHeartbeat = Date.now(); 
}

if (players.peer.active && Date.now() - players.peer.lastSeen > 10000) { 
players.peer.active = false; 
addMsg("SISTEMA", `${players.peer.nick} desconectou.`, "msg-sys"); 
}

const hour = dayCycle.time / 60;
const isHordeDay = (dayCycle.day % 3 === 0);
const isHordeTime = (hour >= 22 || hour < 6);

if (isHordeDay && isHordeTime) {
if (!isWaveActive && !isWavePrepActive) {
isWaveActive = true;
enemiesSpawnedInWave = 0;
enemiesKilledInWave = 0;
addMsg("SISTEMA", "A HORDA EST√Å CHEGANDO!", "msg-sys");
}
} else {
if (isWaveActive || isWavePrepActive) {
isWaveActive = false;
isWavePrepActive = false;
enemies = [];
addMsg("SISTEMA", "A horda recuou com o amanhecer.", "msg-sys");
saveGameProgress();
}
}

if (isWavePrepActive) {
wavePrepTimer -= 1/60;
if (wavePrepTimer <= 0) {
isWavePrepActive = false;
isWaveActive = true;
enemiesSpawnedInWave = 0;
addMsg("SISTEMA", "O descanso acabou! L√° vem eles!", "msg-sys");
}
}

if (isWaveActive) {
let now = Date.now();
if (enemiesSpawnedInWave < 20 && now - lastEnemySpawnTime > 1500) {
const angle = Math.random() * Math.PI * 2;
enemies.push({ 
id: Math.random().toString(36).substr(2, 9),
x: hive.x + Math.cos(angle) * 1000, 
y: hive.y + Math.sin(angle) * 1000, 
hp: 100, vx: 0, vy: 0, 
behavior: Math.random() < 0.35 ? 'hunter' : 'rusher' 
});
enemiesSpawnedInWave++; 
lastEnemySpawnTime = now;
}

if (enemiesKilledInWave >= 20 && enemies.length === 0) {
isWaveActive = false;
isWavePrepActive = true;
wavePrepTimer = 60;
enemiesKilledInWave = 0;
addMsg("SISTEMA", "Grupo derrotado! 60s para se preparar.", "msg-sys");
}
}

enemies.forEach((en) => {
let tx = hive.x, ty = hive.y;
if (hive.destroyed || en.behavior === 'hunter') {
let dMe = !players.me.isDead ? Math.hypot(en.x - players.me.x, en.y - players.me.y) : Infinity;
let dPe = (players.peer.active && !players.peer.isDead) ? Math.hypot(en.x - players.peer.x, en.y - players.peer.y) : Infinity;
if (dMe < Infinity || dPe < Infinity) { 
if (dMe <= dPe) { tx = players.me.x; ty = players.me.y; } 
else { tx = players.peer.x; ty = players.peer.y; } 
}
}
const angle = Math.atan2(ty - en.y, tx - en.x);
en.vx = Math.cos(angle) * 2.0; en.vy = Math.sin(angle) * 2.0;
en.x += en.vx; en.y += en.vy;

if (!hive.destroyed && Math.hypot(en.x - hive.x, en.y - hive.y) < 50) { 
if(performance.now() % 60 < 2) hive.hp -= 1.5; 
}
if (Math.hypot(en.x - players.me.x, en.y - players.me.y) < 30 && performance.now() % 60 < 2) takeDamage(2);
if(players.peer.active && !players.peer.isDead && Math.hypot(en.x - players.peer.x, en.y - players.peer.y) < 30 && performance.now() % 60 < 2) { 
conn.send({type:'hit', target:'me', amount: 2}); 
}
});

const aliveEnemies = enemies.filter(en => en.hp > 0);
if (aliveEnemies.length < enemies.length) {
enemiesKilledInWave += (enemies.length - aliveEnemies.length);
}
enemies = aliveEnemies;

if (hive.hp <= 0 && !hive.destroyed) { 
hive.hp = 0; hive.destroyed = true; 
addMsg("SISTEMA", "COLMEIA DESTRU√çDA!", "msg-sys");
saveGameProgress(); 
}

if (players.peer.active && conn && conn.open && performance.now() - lastNetUpdate > 50) {
conn.send({ 
type: 'sync_world', 
enemies: enemies.map(e => ({id: e.id, x: e.x, y: e.y, vx: e.vx, vy: e.vy, hp: e.hp})), 
isWaveActive: isWaveActive, 
hiveHp: hive.hp, 
hiveDestroyed: hive.destroyed,
dayCycle: { time: dayCycle.time, day: dayCycle.day },
wavePrepTimer: wavePrepTimer,
isWavePrepActive: isWavePrepActive
});
lastNetUpdate = performance.now();
}
}

function spawnFlower(x, y) {
const types = ["üå∏", "üåª", "üå∑"];
const id = flowers.length + 9000; 
flowers.push({
id: id, x: x, y: y, emoji: types[Math.floor(Math.random() * types.length)],
cooldown: 0, maxCooldown: 300, phase: Math.random() * Math.PI * 2, growState: 'seed', plantTime: Date.now()
});
if(players.peer.active && conn && conn.open) conn.send({ type: 'sync_flowers_list', data: flowers });
}

function updateDayCycle() {
if(isHost) {
dayCycle.time += dayCycle.speed / 60;
if(dayCycle.time >= 1440) {
dayCycle.time = 0;
dayCycle.day++;
addMsg("SISTEMA", `In√≠cio do Dia ${dayCycle.day}`, "msg-sys");
}
}

const hour = dayCycle.time / 60;
const isNightNow = hour < 6 || hour > 18;
dayCycle.isNight = isNightNow;

if (hour >= 18 && hour <= 20) dayCycle.overlayAlpha = (hour - 18) / 4; 
else if (hour > 20 || hour < 4) dayCycle.overlayAlpha = 0.5; 
else if (hour >= 4 && hour <= 6) dayCycle.overlayAlpha = 0.5 - ((hour - 4) / 4); 
else dayCycle.overlayAlpha = 0;

const h = Math.floor(hour).toString().padStart(2, '0');
const m = Math.floor((hour % 1) * 60).toString().padStart(2, '0');
const hud = document.getElementById('time-hud');
hud.style.display = 'flex';
hud.innerText = `${isNightNow ? 'üåô' : '‚òÄÔ∏è'} Dia ${dayCycle.day} ‚Ä¢ ${h}:${m}`;
}

function updateMechanics() {
updateDayCycle();
let amICalling = false;
if(players.me.skills.regen && !players.me.isDead && performance.now() % 2000 < 20) {
if(players.me.hp < players.me.maxHp) players.me.hp += 1;
}
if(isHost) {
let needsFlowerSync = false; const now = Date.now();
if(Date.now() - lastAutoSaveTime > 60000) {
saveGameProgress();
lastAutoSaveTime = Date.now();
}

if(players.me.pollen > 0 && !players.me.isDead) {
if(joyMove.dx !== 0 || joyMove.dy !== 0 || (keys['KeyW']||keys['ArrowUp']||keys['KeyS']||keys['ArrowDown']||keys['KeyA']||keys['ArrowLeft']||keys['KeyD']||keys['ArrowRight'])) {
if(Math.random() < 0.3) {
createParticles(players.me.x, players.me.y, "#fffa65", 1, 'pollen');
if(conn && conn.open) conn.send({ type: 'fx', effect: 'pollen', x: players.me.x, y: players.me.y });
}
players.me.pollen = Math.max(0, players.me.pollen - 0.05);
if(Math.random() < 0.002) spawnFlower(players.me.x, players.me.y);
}
}
if(players.peer.active && !players.peer.isDead && players.peer.pollen > 0) {
if(Math.random() < 0.3) createParticles(players.peer.x, players.peer.y, "#fffa65", 1, 'pollen');
if(Math.random() < 0.002) spawnFlower(players.peer.x, players.peer.y);
}
flowers.forEach(f => {
if(f.growState !== 'mature') {
const age = now - f.plantTime;
if(f.growState === 'seed' && age >= 120000) { f.growState = 'sprout'; needsFlowerSync = true; }
if(f.growState === 'sprout' && age >= 300000) { f.growState = 'mature'; needsFlowerSync = true; }
}
});
if(needsFlowerSync && players.peer.active && conn && conn.open) conn.send({ type: 'sync_flowers_list', data: flowers });
}

flowers.forEach((f, idx) => {
if(f.growState === 'mature') {
if(f.cooldown > 0) f.cooldown -= 1/60;
else if(Math.hypot(players.me.x - f.x, players.me.y - f.y) < 50 && players.me.pollen < 100) {
amICalling = true; 
if(isHost) {
const collectionRate = players.me.skills.pollen ? 0.8 : 0.4;
players.me.pollen += collectionRate; addXp(0.02); 
if(players.me.pollen >= 100) { f.cooldown = f.maxCooldown; players.me.pollen = 100; if(players.peer.active && conn && conn.open) conn.send({ type: 'sync_flower_cd', id: f.id, time: f.maxCooldown }); }
} else { if(Math.random() < 0.1) conn.send({ type: 'req_pollen', id: f.id }); }
}
}
});

players.me.isCollecting = amICalling;

const distToHive = Math.hypot(players.me.x - hive.x, players.me.y - hive.y);
if(distToHive < 120 && players.me.pollen > 0 && !players.me.isDead) {
btnRepairHive.style.display = 'flex';
} else {
btnRepairHive.style.display = 'none';
}

for (let i = projectiles.length - 1; i >= 0; i--) {
let p = projectiles[i]; let hit = false;
for (let j = 0; j < enemies.length; j++) {
let en = enemies[j];
if(Math.hypot(p.x - en.x, p.y - en.y) < 35) {
if(isHost) {
const dmg = p.owner === 'me' ? (25 + players.me.stats.str * 5) : 25;
en.hp -= dmg; createParticles(en.x, en.y, "#ff0000", 5);
if(players.peer.active && conn && conn.open) conn.send({ type: 'fx', effect: 'damage', x: en.x, y: en.y });
if(en.hp <= 0) { 
createParticles(en.x, en.y, "#000", 10); 
if(players.peer.active && conn && conn.open) conn.send({ type: 'fx', effect: 'death', x: en.x, y: en.y });
if(players.peer.active && !players.peer.isDead) { addXp(15); if(conn && conn.open) conn.send({ type: 'reward_xp', amount: 15 }); } 
else { addXp(30); }
}
} hit = true; break; 
}
}
if(hit) { projectiles.splice(i, 1); continue; }
p.x += p.vx; p.y += p.vy; p.life--; if(p.life <= 0) projectiles.splice(i, 1);
}
particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= p.decay; if(p.life <= 0) particles.splice(i, 1); });
}

function repairHiveAction() {
if(players.me.isDead || players.me.pollen <= 0) return;
const amountPollen = players.me.pollen;
players.me.pollen = 0; 
if(players.me.hp < players.me.maxHp) {
players.me.hp = Math.min(players.me.maxHp, players.me.hp + 20);
createParticles(players.me.x, players.me.y, "#2ecc71", 10); 
addMsg("SISTEMA", "Curado (+20 HP).", "msg-sys");
}
if(isHost) {
const hpGain = (amountPollen / 100) * (hive.destroyed ? 50 : 100);
hive.hp = Math.min(hive.maxHp, hive.hp + hpGain);
if(hive.hp > 0) { 
if(hive.destroyed) {
addMsg("SISTEMA", "REINO RECONSTRU√çDO!", "msg-sys"); 
saveGameProgress(); 
}
hive.destroyed = false; 
}
createParticles(hive.x, hive.y, "#ff4d4d", 15, 'heart'); 
addXp(Math.floor(amountPollen * 0.15));
} else { 
conn.send({ type: 'repair', pollen: amountPollen }); 
}
}

btnRepairHive.onclick = repairHiveAction;
btnRepairHive.ontouchstart = (e) => { e.preventDefault(); repairHiveAction(); };

function updateHordeHud() {
const hud = document.getElementById('horde-hud');
if (isWaveActive) {
hud.style.display = 'block'; 
hud.style.color = '#ff4757'; 
hud.classList.remove('warn-pulse');
hud.innerText = `‚ö†Ô∏è INVAS√ÉO ATIVA! ‚ö†Ô∏è`;
} else if (isWavePrepActive) {
hud.style.display = 'block'; 
hud.style.color = '#f1c40f'; 
hud.classList.add('warn-pulse');
hud.innerText = `PREPARA√á√ÉO: ${Math.ceil(wavePrepTimer)}s`;
} else { 
hud.style.display = 'none'; 
}
}

function drawIndicators() {
if (players.peer.active && !players.peer.isDead) {
const dx = players.peer.x - players.me.x, dy = players.peer.y - players.me.y;
if (Math.hypot(dx, dy) > 150) drawArrow(dx, dy, players.peer.color);
}
if(!hive.destroyed) {
const hdx = hive.x - players.me.x, hdy = hive.y - players.me.y;
if (Math.hypot(hdx, hdy) > 200) drawArrow(hdx, hdy, "#f1c40f", 90);
}
}

function drawArrow(dx, dy, color, radius = 70) {
const angle = Math.atan2(dy, dx);
ctx.save(); ctx.translate(players.me.x, players.me.y); ctx.rotate(angle);
ctx.beginPath(); ctx.moveTo(radius, 0); ctx.lineTo(radius - 15, -8); ctx.lineTo(radius - 15, 8); ctx.closePath();
ctx.fillStyle = color; ctx.fill(); ctx.restore();
}

function drawSight() {
if(players.me.isDead) return;
if (!isMouseDown && !joyAim.active) return;
let targetX, targetY;
if (joyAim.active) {
targetX = players.me.x + Math.cos(players.me.aimAngle) * 150;
targetY = players.me.y + Math.sin(players.me.aimAngle) * 150;
} else {
const dx = mousePos.x - canvas.width/2;
const dy = mousePos.y - canvas.height/2;
const dist = Math.min(Math.hypot(dx, dy), 150);
targetX = players.me.x + Math.cos(players.me.aimAngle) * dist;
targetY = players.me.y + Math.sin(players.me.aimAngle) * dist;
}
ctx.beginPath(); ctx.setLineDash([5, 10]); ctx.moveTo(players.me.x, players.me.y);
ctx.lineTo(targetX, targetY); ctx.strokeStyle = "rgba(255, 71, 87, 0.4)"; ctx.lineWidth = 2;
ctx.stroke(); ctx.setLineDash([]); ctx.beginPath(); ctx.arc(targetX, targetY, 4, 0, Math.PI * 2);
ctx.fillStyle = "#ff4757"; ctx.fill(); ctx.strokeStyle = "white"; ctx.lineWidth = 1; ctx.stroke();
}

function sendMsg() {
const text = chatInput.value.trim(); if(!text) return;
addMsg(players.me.nick, text, "me");
if(conn && conn.open) conn.send({ type: 'chat', msg: text });
chatInput.value = ""; chatInput.blur();
}

function addMsg(author, text, senderType) {
const d = document.createElement('div');
const color = (senderType === "me") ? players.me.color : ((senderType === "peer") ? players.peer.color : "#aaa");
d.innerHTML = `<span style="color:${color}; font-weight:bold">${author}:</span> ${text}`;
const display = document.getElementById('chat-display'); display.appendChild(d); display.scrollTop = display.scrollHeight;
if (window.getComputedStyle(chatWrapper).left.includes('-') && senderType !== "msg-sys") chatMinimizeBtn.classList.add('unread-pulse');
}

function startGame() {
document.getElementById('menu').style.display = 'none';
document.getElementById('lvl-hud').style.display = 'block';
chatWrapper.style.display = 'flex'; sessionPanel.style.display = 'block'; hivePanel.style.display = 'block'; canvas.style.display = 'block';
if('ontouchstart' in window) { moveBase.style.display = 'block'; aimBase.style.display = 'block'; setupMultitouch(); }
resize(); requestAnimationFrame(gameLoop);
}

function setupMultitouch() {
const handleStart = (e) => {
for(let t of e.changedTouches) {
const rM = moveBase.getBoundingClientRect(), rA = aimBase.getBoundingClientRect();
if(t.clientX > rM.left && t.clientX < rM.right && t.clientY > rM.top && t.clientY < rM.bottom) touchIds.move = t.identifier;
if(t.clientX > rA.left && t.clientX < rA.right && t.clientY > rA.top && t.clientY < rA.bottom) touchIds.aim = t.identifier;
}
};
const handleMove = (e) => {
e.preventDefault();
for(let t of e.touches) {
if(t.identifier === touchIds.move) {
const r = moveBase.getBoundingClientRect();
const dx = t.clientX - (r.left + 60), dy = t.clientY - (r.top + 60);
const d = Math.min(Math.sqrt(dx*dx + dy*dy), 40), a = Math.atan2(dy, dx);
moveStick.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
joyMove = { dx: Math.cos(a)*(d/40), dy: Math.sin(a)*(d/40) };
}
if(t.identifier === touchIds.aim) {
const r = aimBase.getBoundingClientRect();
const dx = t.clientX - (r.left + 60), dy = t.clientY - (r.top + 60);
const d = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
joyAim.angle = Math.atan2(dy, dx); joyAim.active = true;
aimStick.style.transform = `translate(${Math.cos(joyAim.angle)*d}px, ${Math.sin(joyAim.angle)*d}px)`;
players.me.aimAngle = joyAim.angle;
}
}
};
const handleEnd = (e) => {
for(let t of e.changedTouches) {
if(t.identifier === touchIds.move) { touchIds.move = null; joyMove = {dx:0, dy:0}; moveStick.style.transform = 'none'; }
if(t.identifier === touchIds.aim) { touchIds.aim = null; joyAim.active = false; aimStick.style.transform = 'none'; }
}
};
window.addEventListener('touchstart', handleStart, {passive: false});
window.addEventListener('touchmove', handleMove, {passive: false});
window.addEventListener('touchend', handleEnd);
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);

function getDirFromAngle(angle) {
const deg = angle * (180 / Math.PI);
if (deg >= -45 && deg <= 45) return 'Right';
if (deg > 45 && deg < 135) return 'Down';
if (deg >= 135 || deg <= -135) return 'Left';
return 'Up';
}

function update() {
if(!players.me.isDead) {
const baseSpeed = 5 + (players.me.stats.agi * 0.4);
let dx = joyMove.dx, dy = joyMove.dy;
if (keys['KeyW'] || keys['ArrowUp']) dy = -1; if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
if (keys['KeyA'] || keys['ArrowLeft']) dx = -1; if (keys['KeyD'] || keys['ArrowRight']) dx = 1;
players.me.moving = (dx !== 0 || dy !== 0);
if (players.me.moving) {
const m = Math.sqrt(dx*dx + dy*dy);
let newX = players.me.x + (dx/m) * baseSpeed;
let newY = players.me.y + (dy/m) * baseSpeed;
const distToHive = Math.hypot(newX - hive.x, newY - hive.y);
const hiveRadius = 40; 
if (distToHive > hiveRadius) {
players.me.x = newX;
players.me.y = newY;
} else {
const angleFromHive = Math.atan2(newY - hive.y, newX - hive.x);
players.me.x = hive.x + Math.cos(angleFromHive) * (hiveRadius + 1);
players.me.y = hive.y + Math.sin(angleFromHive) * (hiveRadius + 1);
}
if (!joyAim.active && !isMouseDown) { 
if(Math.abs(dx) > Math.abs(dy)) players.me.dir = dx > 0 ? 'Right' : 'Left'; 
else players.me.dir = dy > 0 ? 'Down' : 'Up'; 
}
}
if(joyAim.active) { 
players.me.dir = getDirFromAngle(joyAim.angle); 
players.me.aimAngle = joyAim.angle; 
fire(joyAim.angle); 
} 
else if(isMouseDown || !('ontouchstart' in window)) { 
const angle = Math.atan2(mousePos.y - canvas.height/2, mousePos.x - canvas.width/2); 
players.me.aimAngle = angle; 
if(isMouseDown) {
players.me.dir = getDirFromAngle(angle); 
fire(angle);
}
}
}
runWaveLogic(); updateMechanics(); updateHordeHud();
if(performance.now() - lastNetUpdate > 30) { 
if(conn && conn.open) conn.send({ 
type: 'pos',
x: players.me.x, y: players.me.y, dir: players.me.dir,
hp: players.me.hp, maxHp: players.me.maxHp, isDead: players.me.isDead,
pollen: players.me.pollen, lvl: players.me.lvl, isCollecting: players.me.isCollecting,
moving: players.me.moving 
}); 
lastNetUpdate = performance.now();
}
let playerListHtml = `<div class="item-row" style="color:${players.me.color}"><span>‚óè Voc√™ (${players.me.nick})</span><span>Lvl ${players.me.lvl}</span></div>`;
if(players.peer.active) { 
players.peer.x += (players.peer.tX - players.peer.x) * 0.15; players.peer.y += (players.peer.tY - players.peer.y) * 0.15; 
const d = Math.floor(Math.hypot(players.peer.x-players.me.x, players.peer.y-players.me.y)/10);
playerListHtml += `<div class="item-row" style="color:${players.peer.color}"><span>‚óè ${players.peer.nick}</span><span>${d}m</span></div>`;
}
playerItemsContainer.innerHTML = playerListHtml;
let hiveListHtml = "";
if(!hive.destroyed) {
const hpP = Math.floor((hive.hp/hive.maxHp)*100);
const dist = Math.floor(Math.hypot(hive.x-players.me.x, hive.y-players.me.y)/10);
hiveListHtml += `<div class="item-row" style="color:${hpP > 30 ? '#2ecc71':'#e74c3c'}"><span>üè† Base Principal</span><span>${hpP}% (${dist}m)</span></div>`;
} else { hiveListHtml = `<div class="item-row" style="color:#e74c3c"><span>üè† Base Destru√≠da</span></div>`; }
hiveItemsContainer.innerHTML = hiveListHtml;
camera.x = players.me.x - canvas.width/2; camera.y = players.me.y - canvas.height/2;
document.getElementById('coords').innerText = `X: ${Math.floor(players.me.x)} Y: ${Math.floor(players.me.y)}`;
}

function drawHealthBar(x, y, hp, max = 100, w = 50, h = 6, offset = 55) {
ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(x - w/2, y - offset, w, h);
ctx.fillStyle = hp > (max * 0.3) ? "#2ecc71" : "#e74c3c"; ctx.fillRect(x - w/2, y - offset, w * (hp/max), h);
}

function drawPollenBar(x, y, pollen, w = 50, h = 6, offset = -40) {
ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(x - w/2, y - offset, w, h);
ctx.fillStyle = "#fffa65"; ctx.fillRect(x - w/2, y - offset, w * (pollen/100), h);
ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 1; ctx.strokeRect(x - w/2, y - offset, w, h);
}

function draw() {
ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
ctx.save(); ctx.translate(-camera.x, -camera.y);
const sX = Math.floor(camera.x/TILE_SIZE)*TILE_SIZE, sY = Math.floor(camera.y/TILE_SIZE)*TILE_SIZE;
for(let x=sX; x<sX+canvas.width+TILE_SIZE; x+=TILE_SIZE) 
for(let y=sY; y<sY+canvas.height+TILE_SIZE; y+=TILE_SIZE) 
if(assets.ground.complete) ctx.drawImage(assets.ground, x, y, TILE_SIZE, TILE_SIZE);
flowers.forEach(f => {
if(f.growState === 'seed') return;
const sway = Math.sin(performance.now() * 0.003 + f.phase) * 5;
ctx.font = "28px Arial"; ctx.textAlign = "center"; ctx.globalAlpha = f.cooldown > 0 ? 0.3 : 1.0;
ctx.fillText(f.growState === 'sprout' ? "üå±" : f.emoji, f.x + sway, f.y);
});
ctx.globalAlpha = 1.0;
ctx.font = "60px Arial"; ctx.textAlign = "center"; 
if(hive.destroyed) ctx.globalAlpha = 0.4;
ctx.fillText("üè†", hive.x, hive.y + 20);
ctx.globalAlpha = 1.0;
if(!hive.destroyed && hive.hp < hive.maxHp) drawHealthBar(hive.x, hive.y, hive.hp, hive.maxHp, 100, 10, 60);
else if(hive.destroyed) { ctx.fillStyle = "#e74c3c"; ctx.font = "bold 14px Segoe UI"; ctx.fillText("DESTRU√çDA", hive.x, hive.y - 50); }
drawIndicators();
enemies.forEach(en => { ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("üêú", en.x, en.y); drawHealthBar(en.x, en.y, en.hp, 100, 30, 4, 30); });
projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); });
particles.forEach(p => { ctx.globalAlpha = p.life; if(p.type === 'heart') { ctx.font = "20px Arial"; ctx.fillText("‚ù§Ô∏è", p.x, p.y); } else { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3); } });
ctx.globalAlpha = 1.0;
drawSight();
const drawB = (p, c, a, isMe) => {
if(p.isDead) return;
let sprite;
if (p.moving) sprite = assets.bee[p.dir];
else sprite = assets.bee[p.dir + "Idle"];
if(!sprite || !sprite.complete) return;
ctx.globalAlpha = a; 
ctx.drawImage(sprite, p.x-32, p.y-32, 64, 64);
ctx.globalAlpha = 1; 
ctx.font = "bold 14px Segoe UI"; 
ctx.fillStyle = c; 
ctx.textAlign = "center"; 
ctx.fillText(`${p.nick} (Lvl ${p.lvl})`, p.x, p.y-40);
if(p.hp < p.maxHp) drawHealthBar(p.x, p.y, p.hp, p.maxHp || 100);
if(p.pollen > 0 || p.isCollecting) drawPollenBar(p.x, p.y, p.pollen);
};
drawB(players.me, players.me.color, 1, true);
if(players.peer.active) drawB(players.peer, players.peer.color, 0.6, false);
ctx.restore();
if(dayCycle.overlayAlpha > 0) {
ctx.fillStyle = `rgba(0, 20, 50, ${dayCycle.overlayAlpha})`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
}
}
function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
</script>
</body>
</html>
