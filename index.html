<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>The Hive Kingdom</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
:root { 
--primary: #f1c40f; 
--primary-dark: #d4ac0d;
--secondary: #3498db;
--bg-dark: rgba(20, 20, 20, 0.85); 
--text-main: #ffffff; 
--xp-color: #3498db; 
--border: rgba(255, 255, 255, 0.1); 
--glass: rgba(255, 255, 255, 0.05);
}

body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; color: var(--text-main); touch-action: none; user-select: none; }
canvas { display: none; image-rendering: pixelated; }

/* HUD CENTRAL */
#central-hud {
position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
display: flex; flex-direction: column; align-items: center; gap: 8px;
z-index: 100; pointer-events: none;
}
#lvl-hud {
background: var(--bg-dark); padding: 10px 25px; border-radius: 25px;
text-align: center; min-width: 220px; backdrop-filter: blur(10px);
border: 1px solid var(--border); display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}
#xp-bar-container { width: 100%; height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; margin-top: 6px; overflow: hidden; }
#xp-bar-fill { width: 0%; height: 100%; background: var(--xp-color); transition: width 0.3s; box-shadow: 0 0 8px var(--xp-color); }
#lvl-text { font-weight: bold; color: var(--primary); font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
#coords { 
font-family: monospace; color: var(--primary); background: var(--bg-dark); 
padding: 4px 15px; border-radius: 12px; font-size: 12px; 
border: 1px solid var(--border); backdrop-filter: blur(5px);
opacity: 0.9; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
}

/* HUD DA HORDA */
#horde-hud {
font-family: monospace; font-weight: 800; color: #e74c3c;
background: var(--bg-dark); padding: 5px 20px; border-radius: 12px;
font-size: 16px; border: 1px solid rgba(231, 76, 60, 0.3);
backdrop-filter: blur(5px); display: none; margin-top: 5px;
text-transform: uppercase; letter-spacing: 1px;
text-align: center; box-shadow: 0 0 15px rgba(231, 76, 60, 0.2);
}

.warn-pulse { animation: warnPulse 1s infinite alternate; }

@keyframes warnPulse {
from { transform: scale(1); opacity: 0.8; box-shadow: 0 0 10px rgba(231, 76, 60, 0.2); }
to { transform: scale(1.05); opacity: 1; box-shadow: 0 0 25px rgba(231, 76, 60, 0.6); color: #ff6b6b; }
}

#sidebar-container {
position: absolute; left: 0; top: 100px; z-index: 101;
display: flex; flex-direction: column; pointer-events: none;
}

.side-panel {
position: relative; left: -210px; width: 210px;
transition: left 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
pointer-events: auto;
}

.side-panel.active { left: 0px; }

.panel-content { 
background: var(--bg-dark); padding: 15px; border-radius: 0 12px 12px 0; 
border-left: 4px solid var(--primary); font-size: 13px; 
backdrop-filter: blur(10px); border: 1px solid var(--border);
box-shadow: 5px 5px 15px rgba(0,0,0,0.4);
overflow: hidden;
}

.panel-toggle {
position: absolute; right: -45px; top: 0;
width: 45px; height: 45px; background: var(--primary);
border: none; border-radius: 0 8px 8px 0; cursor: pointer;
font-size: 20px; display: flex; align-items: center; justify-content: center;
box-shadow: 2px 0 10px rgba(0,0,0,0.2); color: #111;
}

.panel-title { 
font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid var(--primary); 
padding-bottom: 5px; color: var(--primary); font-size: 11px; letter-spacing: 1px;
text-transform: uppercase;
}

.item-row { display: flex; justify-content: space-between; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); }

#bottom-menu-container {
position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
display: flex; flex-direction: column; align-items: center; gap: 15px;
z-index: 500;
}
#main-action-menu {
background: var(--bg-dark); border: 1px solid var(--primary);
padding: 15px; border-radius: 15px; display: none;
backdrop-filter: blur(10px); box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
grid-template-columns: repeat(3, 1fr); gap: 10px;
}
.square-btn {
width: 50px; height: 50px; background: rgba(255,255,255,0.1);
border: 1px solid rgba(255,255,255,0.2); border-radius: 10px;
cursor: pointer; display: flex; align-items: center; justify-content: center;
font-size: 24px; transition: all 0.2s;
}
.square-btn:hover { background: var(--primary); transform: scale(1.05); }
#btn-open-menu {
width: 60px; height: 60px; background: var(--primary);
border: 4px solid rgba(0,0,0,0.2); border-radius: 50%;
cursor: pointer; font-size: 28px; display: flex; align-items: center;
justify-content: center; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
z-index: 501;
}

#death-modal, #game-over-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
.modal-title { color: #e74c3c; font-size: 48px; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 5px; text-align: center; }

#chat-wrapper { 
position: absolute; bottom: 220px; left: -240px; width: 240px; z-index: 500; 
display: none; flex-direction: column; transition: left 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
}
#chat-display { height: 160px; background: var(--bg-dark); border-radius: 0 12px 0 0; padding: 12px; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; border: 1px solid var(--border); backdrop-filter: blur(15px); font-size: 13px; }
#chat-input-area { display: flex; background: rgba(30, 30, 30, 0.95); padding: 8px; border-radius: 0 0 12px 0; border: 1px solid var(--border); }
#chat-input { flex: 1; background: transparent; border: none; color: white; padding: 4px; font-size: 14px; outline: none; }

#btn-minimize-chat { 
position: absolute; right: -45px; bottom: 0; 
background: var(--primary); color: #111; 
border: none; border-radius: 0 8px 8px 0; cursor: pointer; 
width: 45px; height: 45px; 
font-size: 20px; font-weight: bold; 
box-shadow: 4px 0 10px rgba(0,0,0,0.3); 
transition: background 0.3s;
}

@keyframes pulse {
0% { transform: scale(1); box-shadow: 4px 0 10px rgba(0,0,0,0.3); }
50% { transform: scale(1.1); box-shadow: 0 0 20px var(--primary); background: #fff176; }
100% { transform: scale(1); box-shadow: 4px 0 10px rgba(0,0,0,0.3); }
}

.unread-pulse { animation: pulse 1.5s infinite ease-in-out !important; z-index: 502; }

#menu { 
position: fixed; top: 0; left: 0; width: 100%; height: 100%;
display: flex; flex-direction: column; align-items: center; justify-content: center;
background: linear-gradient(135deg, #121212 0%, #1a1a1a 100%);
z-index: 3000; padding: 20px; box-sizing: border-box;
}

.menu-card {
background: rgba(40, 40, 40, 0.6);
backdrop-filter: blur(20px);
border: 1px solid var(--border);
border-radius: 24px;
padding: 40px;
width: 100%;
max-width: 500px;
box-shadow: 0 20px 50px rgba(0,0,0,0.5);
text-align: center;
}

.menu-card h1 {
font-size: 2.8rem; margin: 0;
background: linear-gradient(to bottom, #fff, var(--primary));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
letter-spacing: -1px; font-weight: 800;
text-transform: uppercase;
}

.menu-card .slogan {
color: var(--primary); font-size: 0.85rem; font-weight: 600;
letter-spacing: 2px; margin-bottom: 20px; text-transform: uppercase; opacity: 0.9;
}

.menu-card p.version { color: #888; margin-bottom: 30px; font-size: 0.75rem; }

#studio-footer { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; }
.studio-name { font-size: 14px; text-transform: uppercase; letter-spacing: 4px; color: rgba(255, 255, 255, 0.5); }
.studio-name b { color: var(--primary); font-weight: 800; }
.tight-cookie { display: inline-block; margin-left: -5px; margin-right: -4px; transform: translateY(1px); }

.input-group { margin-bottom: 20px; text-align: left; }
.input-group label { display: block; font-size: 0.75rem; text-transform: uppercase; color: var(--primary); margin-bottom: 8px; font-weight: bold; padding-left: 5px; }

.menu-input {
width: 100%; padding: 14px 18px;
background: rgba(0, 0, 0, 0.3);
border: 1px solid var(--border);
border-radius: 12px;
color: white; font-size: 1rem;
box-sizing: border-box;
transition: border-color 0.3s, box-shadow 0.3s;
}

.menu-input:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 4px rgba(241, 196, 15, 0.1); }

.button-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px; }

.main-btn {
padding: 16px; cursor: pointer; border-radius: 12px; border: none;
font-weight: 800; font-size: 0.9rem; text-transform: uppercase;
letter-spacing: 1px; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
display: flex; align-items: center; justify-content: center; gap: 10px;
}

.btn-create { background: var(--primary); color: #111; }
.btn-create:hover { background: var(--primary-dark); transform: translateY(-2px); }
.btn-join { background: var(--secondary); color: white; }
.btn-join:hover { filter: brightness(1.1); transform: translateY(-2px); }
.main-btn:active { transform: scale(0.95); }

.joy-container { position: absolute; bottom: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; display: none; border: 2px solid rgba(255,255,255,0.2); z-index: 150; }
#move-base { left: 40px; }
#aim-base { right: 40px; border-color: rgba(255, 71, 87, 0.3); }
.joy-stick { position: absolute; width: 50px; height: 50px; border-radius: 50%; top: 35px; left: 35px; pointer-events: none; opacity: 0.8; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
</style>
</head>
<body>

<div id="central-hud">
<div id="lvl-hud">
<div id="lvl-text">N√≠vel 1</div>
<div id="xp-bar-container"><div id="xp-bar-fill"></div></div>
</div>
<div id="coords">X: 1100 Y: 1100</div>
<div id="horde-hud"></div>
</div>

<div id="sidebar-container">
<div id="session-panel" class="side-panel">
<button id="btn-session-toggle" class="panel-toggle">üë•</button>
<div class="panel-content">
<div class="panel-title">Sess√£o Ativa</div>
<div id="player-items-container"></div>
</div>
</div>

<div id="hive-panel" class="side-panel">
<button id="btn-hive-toggle" class="panel-toggle">üè†</button>
<div class="panel-content">
<div class="panel-title">Colmeias Ativas</div>
<div id="hive-items-container"></div>
</div>
</div>
</div>

<div id="bottom-menu-container">
<div id="main-action-menu">
<button class="square-btn" title="Abelhas">üêù</button>
<button class="square-btn" style="opacity: 0.3;">‚öôÔ∏è</button>
<button class="square-btn" style="opacity: 0.3;">üéí</button>
</div>
<button id="btn-open-menu">‚ò∞</button>
</div>

<div id="death-modal">
<h2 class="modal-title">Derrotado</h2>
<button class="main-btn btn-create" onclick="respawnPlayer()" style="width: 200px;">RESPAWN</button>
</div>
<div id="game-over-modal">
<h2 class="modal-title">COLMEIA DESTRU√çDA</h2>
<button class="main-btn btn-create" onclick="location.reload()" style="width: 200px;">RECOME√áAR</button>
</div>

<div id="chat-wrapper">
<button id="btn-minimize-chat">üí¨</button>
<div id="chat-display"></div>
<div id="chat-input-area">
<input type="text" id="chat-input" placeholder="Falar..." autocomplete="off">
</div>
</div>

<div id="menu">
<div class="menu-card">
<h1>THE HIVE KINGDOM</h1>
<div class="slogan">Long live the King. Long live the Hive</div>
<p class="version">RPG Multiplayer Edition ‚Ä¢ v1.3</p>

<div class="input-group">
<label>Identidade</label>
<input type="text" id="player-nick" class="menu-input" placeholder="Seu apelido no jogo..." maxlength="12">
</div>

<div class="input-group">
<label>Portal (C√≥digo da Sala)</label>
<input type="text" id="room-code" class="menu-input" placeholder="Ex: ABC123" maxlength="6">
</div>

<div class="button-row">
<button class="main-btn btn-create" onclick="startSession(true)">
<span>üè†</span> Criar Sala
</button>
<button class="main-btn btn-join" onclick="startSession(false)">
<span>üöÄ</span> Entrar
</button>
</div>
</div>

<div id="studio-footer">
<div class="studio-name"><b>FUN<span class="tight-cookie">üç™</span>COOK STUDIO</b></div>
</div>
</div>

<div id="move-base" class="joy-container"><div id="move-stick" class="joy-stick" style="background:var(--primary)"></div></div>
<div id="aim-base" class="joy-container"><div id="aim-stick" class="joy-stick" style="background:#ff4757"></div></div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const chatInput = document.getElementById('chat-input');
const chatWrapper = document.getElementById('chat-wrapper');
const chatMinimizeBtn = document.getElementById('btn-minimize-chat');
const sessionPanel = document.getElementById('session-panel');
const hivePanel = document.getElementById('hive-panel');
const deathModal = document.getElementById('death-modal');
const gameOverModal = document.getElementById('game-over-modal');
const moveBase = document.getElementById('move-base');
const aimBase = document.getElementById('aim-base');
const moveStick = document.getElementById('move-stick');
const aimStick = document.getElementById('aim-stick');
const playerItemsContainer = document.getElementById('player-items-container');
const hiveItemsContainer = document.getElementById('hive-items-container');
const btnOpenMenu = document.getElementById('btn-open-menu');
const mainActionMenu = document.getElementById('main-action-menu');

const assets = { bee: { Down: new Image(), Left: new Image(), Up: new Image(), Right: new Image() }, ground: new Image() };
assets.bee.Down.src = 'BeeDown.png'; assets.bee.Left.src = 'BeeLeft.png'; assets.bee.Up.src = 'BeeUp.png'; assets.bee.Right.src = 'BeeRight.png';
assets.ground.src = 'Grass.png';

let isHost = false;
let hive = { x: 1000, y: 1000, hp: 500, maxHp: 500, destroyed: false };
let players = { 
me: { x: 1100, y: 1100, dir: 'Down', nick: "", color: "#f1c40f", hp: 100, isDead: false, pollen: 0, lvl: 1, xp: 0, nextXp: 100, isCollecting: false }, 
peer: { x: 1100, y: 1100, tX: 1100, tY: 1100, dir: 'Down', nick: "Amigo", color: "#3498db", active: false, hp: 100, isDead: false, pollen: 0, lvl: 1, lastSeen: 0, isCollecting: false } 
};

// BUFFER DE COMANDOS
let networkBuffer = {
repairs: []
};

let projectiles = [], enemies = [], flowers = [], particles = []; 
let camera = { x: 0, y: 0 }, peer, conn, keys = {};
const TILE_SIZE = 64;
let lastNetUpdate = 0, lastShootTime = 0, lastEnemySpawnTime = 0, lastHeartbeat = 0;
let mousePos = { x: 0, y: 0 }, isMouseDown = false;
let touchIds = { move: null, aim: null }, joyMove = { dx: 0, dy: 0 }, joyAim = { angle: 0, active: false };
const TOTAL_WAVE_ENEMIES = 20;
let waveTimer = 180, isWaveActive = false, enemiesSpawnedInWave = 0;

btnOpenMenu.onclick = () => {
const isVisible = mainActionMenu.style.display === 'grid';
mainActionMenu.style.display = isVisible ? 'none' : 'grid';
btnOpenMenu.innerHTML = isVisible ? '‚ò∞' : '‚úï';
};

function toggleChat() {
let currentLeft = window.getComputedStyle(chatWrapper).getPropertyValue('left');
let isHidden = currentLeft.includes('-') || currentLeft === 'auto';
chatWrapper.style.left = isHidden ? "0px" : "-240px";
chatMinimizeBtn.innerHTML = isHidden ? "¬´" : "üí¨";
if (isHidden) chatMinimizeBtn.classList.remove('unread-pulse');
}

chatMinimizeBtn.onclick = toggleChat;
chatMinimizeBtn.ontouchstart = (e) => { e.preventDefault(); toggleChat(); };

document.getElementById('btn-session-toggle').onclick = () => {
sessionPanel.classList.toggle('active');
document.getElementById('btn-session-toggle').innerHTML = sessionPanel.classList.contains('active') ? "¬´" : "üë•";
};

document.getElementById('btn-hive-toggle').onclick = () => {
hivePanel.classList.toggle('active');
document.getElementById('btn-hive-toggle').innerHTML = hivePanel.classList.contains('active') ? "¬´" : "üè†";
};

function addXp(amount) {
if(players.me.isDead) return;
players.me.xp += amount;
if(players.me.xp >= players.me.nextXp) {
players.me.xp -= players.me.nextXp;
players.me.lvl++;
// ESCALONAMENTO DE XP: Aumento exponencial
players.me.nextXp = Math.floor(100 * Math.pow(1.2, players.me.lvl));
addMsg("SISTEMA", `LEVEL UP! N√≠vel ${players.me.lvl}!`, "msg-sys");
createParticles(players.me.x, players.me.y, "#f1c40f", 20, 'pixel');
}
updateXpHud();
}

function updateXpHud() {
const perc = (players.me.xp / players.me.nextXp) * 100;
document.getElementById('xp-bar-fill').style.width = perc + "%";
document.getElementById('lvl-text').innerText = `N√≠vel ${players.me.lvl}`;
}

function createParticles(x, y, color, count, type = 'pixel') {
for(let i=0; i<count; i++) {
let vx = (Math.random() - 0.5) * 4;
let vy = (Math.random() - 0.5) * 4;
let life = 1.0;
let decay = Math.random() * 0.02 + 0.01;
if(type === 'pollen') { vx = (Math.random() - 0.5) * 1.5; vy = Math.random() * 1.5; decay = 0.015 + Math.random() * 0.015; }
else if (type === 'heart') { vx *= 0.5; vy = -Math.random(); decay = 0.01; }
particles.push({ x, y, vx, vy, life, decay, color, type });
}
}

function generateFlowers() {
flowers = [];
const types = ["üå∏", "üåª", "üå∑"];
for(let i=0; i<25; i++) {
flowers.push({
id: i, // ID para sync
x: Math.random() * 4000 - 1000, y: Math.random() * 4000 - 1000,
emoji: types[Math.floor(Math.random() * types.length)],
cooldown: 0, maxCooldown: 300, phase: Math.random() * Math.PI * 2
cooldown: 0, maxCooldown: 300, phase: Math.random() * Math.PI * 2,
growState: 'mature', // Flores iniciais j√° s√£o maduras
plantTime: 0
});
}
}

window.addEventListener('mousemove', e => { mousePos.x = e.clientX; mousePos.y = e.clientY; });
window.addEventListener('mousedown', () => isMouseDown = true);
window.addEventListener('mouseup', () => isMouseDown = false);
window.addEventListener('keydown', e => {
if(document.activeElement === chatInput) { 
if(e.key === 'Enter') { e.preventDefault(); sendMsg(); }
return; 
}
if(e.key === 'Enter') { e.preventDefault(); chatInput.focus(); }
keys[e.code] = true;
});
window.addEventListener('keyup', e => keys[e.code] = false);

function startSession(host) {
const code = document.getElementById('room-code').value.trim();
const nick = document.getElementById('player-nick').value.trim();
if(!nick || !code) return alert("Preencha o Nickname e o C√≥digo!");
isHost = host;
players.me.nick = nick;
players.me.color = host ? "#f1c40f" : "#3498db";
players.peer.color = host ? "#3498db" : "#f1c40f";
peer = host ? new Peer('bee-' + code) : new Peer();
peer.on('open', () => { 
if(host) {
generateFlowers();
startGame(); 
} else { 
conn = peer.connect('bee-' + code); 
setupConn(); 
} 
});
peer.on('connection', c => { conn = c; setupConn(); });
}

function setupConn() {
conn.on('open', () => { 
players.peer.active = true;
players.peer.lastSeen = Date.now();
if(isHost) {
conn.send({ type: 'init_flowers', data: flowers });
} else {
startGame(); 
}
conn.send({ type: 'handshake', nick: players.me.nick, color: players.me.color });
});
conn.on('data', data => {
if(data.type === 'chat') addMsg(players.peer.nick, data.msg, "peer");
else if(data.type === 'shoot') spawnProjectile(data.x, data.y, data.angle, false);
else if(data.type === 'handshake') { players.peer.nick = data.nick; players.peer.color = data.color; }
else if(data.type === 'reward_xp') { addXp(data.amount); }
else if(data.type === 'upd_pollen') { players.me.pollen = data.amount; }
else if(data.type === 'init_flowers') { flowers = data.data; }
else if(data.type === 'sync_flowers_list') { flowers = data.data; } // Sincroniza lista completa
else if(data.type === 'sync_flower_cd') { if(flowers[data.id]) flowers[data.id].cooldown = data.time; }
else if(data.type === 'fx') { 
if(data.effect === 'damage') createParticles(data.x, data.y, "#ff0000", 8);
if(data.effect === 'death') createParticles(data.x, data.y, "#000", 12);
if(data.effect === 'heart') createParticles(data.x, data.y, "#ff4d4d", 15, 'heart');
}
else if(data.type === 'req_pollen') {
if(isHost && flowers[data.id] && flowers[data.id].cooldown <= 0) {
if(isHost && flowers[data.id] && flowers[data.id].growState === 'mature' && flowers[data.id].cooldown <= 0) {
flowers[data.id].cooldown = flowers[data.id].maxCooldown;
players.peer.pollen += 0.4;
conn.send({ type: 'upd_pollen', amount: players.peer.pollen });
conn.send({ type: 'sync_flower_cd', id: data.id, time: flowers[data.id].maxCooldown });
}
}
else if(data.type === 'wave_clear') { // Peer recebe sinal de vit√≥ria
showWaveClearEffect();
}
else if(data.type === 'sync_world') { 
players.peer.lastSeen = Date.now();
enemies = data.enemies.map(enNew => {
let existing = enemies.find(e => e.id === enNew.id);
return existing ? {...enNew} : enNew;
});
isWaveActive = data.isWaveActive; 
hive.hp = data.hiveHp;
// SYNC DO TIMER
waveTimer = data.waveTimer;
enemiesSpawnedInWave = data.enemiesSpawned;
}
else if(data.type === 'repair') { 
if(isHost) {
hive.hp = Math.min(hive.maxHp, hive.hp + 50);
conn.send({ type: 'fx', effect: 'heart', x: hive.x, y: hive.y });
conn.send({ type: 'reward_xp', amount: 15 }); // XP ajustado
}
}
else if(data.type === 'hit') { 
if(!isHost && data.target === 'me') {
takeDamage(data.amount); 
}
}
else if(data.type === 'pos') { 
players.peer.lastSeen = Date.now();
players.peer.tX = data.x; players.peer.tY = data.y; 
players.peer.dir = data.dir; players.peer.hp = data.hp; 
players.peer.isDead = data.isDead; players.peer.pollen = data.pollen; 
players.peer.lvl = data.lvl; players.peer.active = true;
}
else if(data.type === 'ping') { if(!isHost) conn.send({type: 'pong'}); }
else if(data.type === 'pong') { players.peer.lastSeen = Date.now(); }
});
}

function showWaveClearEffect() {
addMsg("SISTEMA", "HORDA DESTRU√çDA! +3 Minutos de Paz.", "msg-sys");
createParticles(hive.x, hive.y, "#3498db", 30, 'pixel'); // Explos√£o azul na base
}

function takeDamage(amount) {
if(players.me.isDead) return;
players.me.hp -= amount;
createParticles(players.me.x, players.me.y, "#ff0000", 5);
if(players.me.hp <= 0) {
players.me.hp = 0; players.me.isDead = true;
deathModal.style.display = 'flex';
players.me.pollen = 0;
}
}

function respawnPlayer() {
players.me.x = 1100; players.me.y = 1100;
players.me.hp = 100; players.me.isDead = false;
deathModal.style.display = 'none';
}

function fire(angle) {
if(Date.now() - lastShootTime < 180 || players.me.isDead) return;
spawnProjectile(players.me.x, players.me.y, angle, true);
// Otimiza√ß√£o: S√≥ envia se peer ativo
if(players.peer.active && conn && conn.open) conn.send({ type: 'shoot', x: players.me.x, y: players.me.y, angle: angle });
lastShootTime = Date.now();
}

function spawnProjectile(x, y, angle, isMe) {
projectiles.push({ x, y, vx: Math.cos(angle)*12, vy: Math.sin(angle)*12, life: 60, color: isMe ? players.me.color : players.peer.color, owner: isMe ? 'me' : 'peer' });
}

function runWaveLogic() {
if (!isHost) {
enemies.forEach(en => { en.x += en.vx; en.y += en.vy; });
return;
}

if(Date.now() - lastHeartbeat > 3000) {
if(conn && conn.open) conn.send({type: 'ping'});
lastHeartbeat = Date.now();
}
if(players.peer.active && Date.now() - players.peer.lastSeen > 10000) {
players.peer.active = false;
addMsg("SISTEMA", `${players.peer.nick} desconectou.`, "msg-sys");
}

while(networkBuffer.repairs.length > 0) {
networkBuffer.repairs.shift();
hive.hp = Math.min(hive.maxHp, hive.hp + 50);
if(players.peer.active && conn && conn.open) {
conn.send({ type: 'fx', effect: 'heart', x: hive.x, y: hive.y });
conn.send({ type: 'reward_xp', amount: 15 }); // XP ajustado
}
}

waveTimer -= 1/60;
if (waveTimer <= 0 && !isWaveActive) { isWaveActive = true; enemiesSpawnedInWave = 0; waveTimer = 180; }

// FIM DA HORDA
if (isWaveActive && enemies.length === 0 && enemiesSpawnedInWave >= TOTAL_WAVE_ENEMIES) {
isWaveActive = false;
waveTimer = 180; // 3 Minutos de paz
showWaveClearEffect();
if(players.peer.active && conn && conn.open) conn.send({type: 'wave_clear'});
}

if (isWaveActive) {
let now = Date.now();
if (enemiesSpawnedInWave < TOTAL_WAVE_ENEMIES && now - lastEnemySpawnTime > 2000) {
const angle = Math.random() * Math.PI * 2;
enemies.push({ 
id: Math.random().toString(36).substr(2, 9),
x: hive.x + Math.cos(angle) * 1000, y: hive.y + Math.sin(angle) * 1000, 
hp: 100, vx: 0, vy: 0
});
enemiesSpawnedInWave++; lastEnemySpawnTime = now;
}
}

enemies.forEach((en) => {
const angle = Math.atan2(hive.y - en.y, hive.x - en.x);
en.vx = Math.cos(angle) * 2.0; en.vy = Math.sin(angle) * 2.0;
en.x += en.vx; en.y += en.vy;

if (!hive.destroyed && Math.hypot(en.x - hive.x, en.y - hive.y) < 50) {
if(performance.now() % 60 < 2) hive.hp -= 2;
}
if (Math.hypot(en.x - players.me.x, en.y - players.me.y) < 30 && performance.now() % 60 < 2) takeDamage(2);
if(players.peer.active && !players.peer.isDead && Math.hypot(en.x - players.peer.x, en.y - players.peer.y) < 30 && performance.now() % 60 < 2) {
conn.send({type:'hit', target:'me', amount: 2}); 
}
});

enemies = enemies.filter(en => en.hp > 0);

if (hive.hp <= 0 && !hive.destroyed) { hive.hp = 0; hive.destroyed = true; setTimeout(() => gameOverModal.style.display = 'flex', 1500); }

// Otimiza√ß√£o: S√≥ manda sync se tiver peer
if (players.peer.active && conn && conn.open && performance.now() - lastNetUpdate > 50) {
conn.send({ 
type: 'sync_world', 
enemies: enemies.map(e => ({id: e.id, x: e.x, y: e.y, vx: e.vx, vy: e.vy, hp: e.hp})), 
isWaveActive: isWaveActive, hiveHp: hive.hp,
waveTimer: waveTimer, // Enviando Timer
enemiesSpawned: enemiesSpawnedInWave // Enviando contagem
});
lastNetUpdate = performance.now();
}
}

// HOST: Cria uma nova flor (Semente)
function spawnFlower(x, y) {
    const types = ["üå∏", "üåª", "üå∑"];
    const id = flowers.length; // Simple ID
    flowers.push({
        id: id,
        x: x, 
        y: y,
        emoji: types[Math.floor(Math.random() * types.length)],
        cooldown: 0, 
        maxCooldown: 300, 
        phase: Math.random() * Math.PI * 2,
        growState: 'seed',
        plantTime: Date.now()
    });
    // Sync imediato ao criar
    if(players.peer.active && conn && conn.open) conn.send({ type: 'sync_flowers_list', data: flowers });
}

function updateMechanics() {
players.me.isCollecting = false; // Reset state
flowers.forEach((f, index) => {
if(f.cooldown > 0) f.cooldown -= 1/60;
else if(Math.hypot(players.me.x - f.x, players.me.y - f.y) < 50 && players.me.pollen < 100) {
players.me.isCollecting = true; // Actively collecting

// L√ìGICA DE POLITIZA√á√ÉO E DROP DE P√ìLEN (Apenas Host processa l√≥gica de spawn)
if(isHost) {
players.me.pollen += 0.4;
addXp(0.02); // NERF XP DE COLETA
if(players.me.pollen >= 100) { 
f.cooldown = f.maxCooldown; 
players.me.pollen = 100;
if(players.peer.active && conn && conn.open) conn.send({ type: 'sync_flower_cd', id: index, time: f.maxCooldown });
}
} else {
if(Math.random() < 0.1) {
conn.send({ type: 'req_pollen', id: index });
}
    let needsFlowerSync = false;
    const now = Date.now();

    // 1. Processar Host (Me)
    if(players.me.pollen > 0 && !players.me.isDead) {
        // Se estiver se movendo
        if(joyMove.dx !== 0 || joyMove.dy !== 0 || (keys['KeyW']||keys['ArrowUp']||keys['KeyS']||keys['ArrowDown']||keys['KeyA']||keys['ArrowLeft']||keys['KeyD']||keys['ArrowRight'])) {
             // Rastro de polen
             if(Math.random() < 0.3) createParticles(players.me.x, players.me.y, "#fffa65", 1, 'pollen');
             players.me.pollen = Math.max(0, players.me.pollen - 0.05);
             
             // Chance de nascer flor (0.2% por tick)
             if(Math.random() < 0.002) {
                 spawnFlower(players.me.x, players.me.y);
             }
        }
    }

    // 2. Processar Peer (Baseado na ultima posi√ß√£o conhecida)
    if(players.peer.active && !players.peer.isDead && players.peer.pollen > 0) {
         // N√£o temos input direto, usamos 'active' e assumimos movimento se posi√ß√£o mudar (mas aqui simplificamos)
         // Vamos apenas checar se ele tem p√≥len. Para simplificar, assumimos que ele se move.
         if(Math.random() < 0.3) createParticles(players.peer.x, players.peer.y, "#fffa65", 1, 'pollen');
         
         if(Math.random() < 0.002) {
             spawnFlower(players.peer.x, players.peer.y);
         }
    }

    // 3. Atualizar crescimento das flores
    flowers.forEach(f => {
        if(f.growState !== 'mature') {
            const age = now - f.plantTime;
            // 2 minutos (120000ms) para virar Broto
            if(f.growState === 'seed' && age >= 120000) {
                f.growState = 'sprout';
                needsFlowerSync = true;
            }
            // 5 minutos (300000ms) para virar Flor
            if(f.growState === 'sprout' && age >= 300000) {
                f.growState = 'mature';
                needsFlowerSync = true;
            }
        }
    });

    if(needsFlowerSync && players.peer.active && conn && conn.open) {
        conn.send({ type: 'sync_flowers_list', data: flowers });
    }
}


flowers.forEach((f, index) => {
// S√≥ interage se for madura
if(f.growState === 'mature') {
    if(f.cooldown > 0) f.cooldown -= 1/60;
    else if(Math.hypot(players.me.x - f.x, players.me.y - f.y) < 50 && players.me.pollen < 100) {
        players.me.isCollecting = true; // Actively collecting
        if(isHost) {
            players.me.pollen += 0.4;
            addXp(0.02); // NERF XP DE COLETA
            if(players.me.pollen >= 100) { 
                f.cooldown = f.maxCooldown; 
                players.me.pollen = 100;
                if(players.peer.active && conn && conn.open) conn.send({ type: 'sync_flower_cd', id: index, time: f.maxCooldown });
            }
        } else {
            if(Math.random() < 0.1) {
                conn.send({ type: 'req_pollen', id: index });
            }
        }
    }
}
});

// Part√≠culas visuais de coleta (mantido para feedback)
if(!players.me.isDead && players.me.pollen > 0 && Math.random() < 0.1) createParticles(players.me.x, players.me.y, "#fffa65", 1, 'pollen');
if(players.peer.active && !players.peer.isDead && players.peer.pollen > 0 && Math.random() < 0.1) createParticles(players.peer.x, players.peer.y, "#fffa65", 1, 'pollen');

if(Math.hypot(players.me.x - hive.x, players.me.y - hive.y) < 60 && !hive.destroyed) {
if(players.me.pollen >= 100 && hive.hp < hive.maxHp) {
players.me.pollen = 0; 
if(isHost) { 
hive.hp = Math.min(hive.maxHp, hive.hp + 50); 
createParticles(hive.x, hive.y, "#ff4d4d", 15, 'heart');
addXp(15); // NERF XP DE REPARO
} else { conn.send({ type: 'repair' }); }
}
}

// CORRE√á√ÉO CR√çTICA: Loop reverso para evitar crash no splice
for (let i = projectiles.length - 1; i >= 0; i--) {
let p = projectiles[i];
let hit = false;

// Check collision with enemies
for (let j = 0; j < enemies.length; j++) {
let en = enemies[j];
if(Math.hypot(p.x - en.x, p.y - en.y) < 35) {
if(isHost) {
en.hp -= 25;
createParticles(en.x, en.y, "#ff0000", 5);
if(players.peer.active && conn && conn.open) conn.send({ type: 'fx', effect: 'damage', x: en.x, y: en.y });

if(en.hp <= 0) { 
createParticles(en.x, en.y, "#000", 10); 
if(players.peer.active && conn && conn.open) conn.send({ type: 'fx', effect: 'death', x: en.x, y: en.y });

// L√ìGICA DE XP COMPARTILHADO (FORMIGAS)
const totalKillXp = 30;
if(players.peer.active && !players.peer.isDead) {
const splitXp = totalKillXp / 2;
addXp(splitXp); // Host ganha metade
if(conn && conn.open) conn.send({ type: 'reward_xp', amount: splitXp }); // Peer ganha metade
} else {
addXp(totalKillXp); // Solo ganha tudo
}
}
} 
hit = true;
break; // Bullet hit something, stop checking other enemies
}
}

if(hit) {
projectiles.splice(i, 1);
continue;
}

// Movement & Life decay
p.x += p.vx; p.y += p.vy; 
p.life--; 
if(p.life <= 0) {
projectiles.splice(i, 1);
}
}

particles.forEach((p, i) => {
p.x += p.vx; p.y += p.vy; p.life -= p.decay;
if(p.life <= 0) particles.splice(i, 1);
});
}

// NOVA FUN√á√ÉO: Gerencia o HUD da Horda
function updateHordeHud() {
const hud = document.getElementById('horde-hud');
if (isWaveActive) {
hud.style.display = 'block';
hud.style.color = '#ff4757';
hud.classList.remove('warn-pulse');
// Calculo de inimigos restantes: (Total - Nascidos) + Vivos na tela
const remaining = (TOTAL_WAVE_ENEMIES - enemiesSpawnedInWave) + enemies.length;
hud.innerText = `‚ö†Ô∏è INVAS√ÉO: ${remaining} ‚ö†Ô∏è`;
} else if (waveTimer <= 60) {
hud.style.display = 'block';
hud.style.color = '#e67e22';
hud.classList.add('warn-pulse');
hud.innerText = `ALERTA: ${Math.ceil(waveTimer)}s`;
} else {
hud.style.display = 'none';
hud.classList.remove('warn-pulse');
}
}

function drawIndicators() {
if (players.peer.active && !players.peer.isDead) {
const dx = players.peer.x - players.me.x, dy = players.peer.y - players.me.y;
if (Math.hypot(dx, dy) > 150) drawArrow(dx, dy, players.peer.color);
}
if(!hive.destroyed) {
const hdx = hive.x - players.me.x, hdy = hive.y - players.me.y;
if (Math.hypot(hdx, hdy) > 200) drawArrow(hdx, hdy, "#f1c40f", 90);
}
}

function drawArrow(dx, dy, color, radius = 70) {
const angle = Math.atan2(dy, dx);
ctx.save(); ctx.translate(players.me.x, players.me.y); ctx.rotate(angle);
ctx.beginPath(); ctx.moveTo(radius, 0); ctx.lineTo(radius - 15, -8); ctx.lineTo(radius - 15, 8); ctx.closePath();
ctx.fillStyle = color; ctx.fill(); ctx.restore();
}

function sendMsg() {
const text = chatInput.value.trim();
if(!text) return;
addMsg(players.me.nick, text, "me");
if(conn && conn.open) conn.send({ type: 'chat', msg: text });
chatInput.value = ""; chatInput.blur();
}

function addMsg(author, text, senderType) {
const d = document.createElement('div');
const color = (senderType === "me") ? players.me.color : ((senderType === "peer") ? players.peer.color : "#aaa");
d.innerHTML = `<span style="color:${color}; font-weight:bold">${author}:</span> ${text}`;
const display = document.getElementById('chat-display');
display.appendChild(d); display.scrollTop = display.scrollHeight;
if (window.getComputedStyle(chatWrapper).left.includes('-') && senderType !== "msg-sys") chatMinimizeBtn.classList.add('unread-pulse');
}

function startGame() {
document.getElementById('menu').style.display = 'none';
document.getElementById('lvl-hud').style.display = 'block';
chatWrapper.style.display = 'flex';
sessionPanel.style.display = 'block';
hivePanel.style.display = 'block';
canvas.style.display = 'block';
if('ontouchstart' in window) { moveBase.style.display = 'block'; aimBase.style.display = 'block'; setupMultitouch(); }
resize(); requestAnimationFrame(gameLoop);
}

function setupMultitouch() {
const handleStart = (e) => {
for(let t of e.changedTouches) {
const rM = moveBase.getBoundingClientRect(), rA = aimBase.getBoundingClientRect();
if(t.clientX > rM.left && t.clientX < rM.right && t.clientY > rM.top && t.clientY < rM.bottom) touchIds.move = t.identifier;
if(t.clientX > rA.left && t.clientX < rA.right && t.clientY > rA.top && t.clientY < rA.bottom) touchIds.aim = t.identifier;
}
};
const handleMove = (e) => {
e.preventDefault();
for(let t of e.touches) {
if(t.identifier === touchIds.move) {
const r = moveBase.getBoundingClientRect();
const dx = t.clientX - (r.left + 60), dy = t.clientY - (r.top + 60);
const d = Math.min(Math.sqrt(dx*dx + dy*dy), 40), a = Math.atan2(dy, dx);
moveStick.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
joyMove = { dx: Math.cos(a)*(d/40), dy: Math.sin(a)*(d/40) };
}
if(t.identifier === touchIds.aim) {
const r = aimBase.getBoundingClientRect();
const dx = t.clientX - (r.left + 60), dy = t.clientY - (r.top + 60);
const d = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
joyAim.angle = Math.atan2(dy, dx); joyAim.active = true;
aimStick.style.transform = `translate(${Math.cos(joyAim.angle)*d}px, ${Math.sin(joyAim.angle)*d}px)`;
}
}
};
const handleEnd = (e) => {
for(let t of e.changedTouches) {
if(t.identifier === touchIds.move) { touchIds.move = null; joyMove = {dx:0, dy:0}; moveStick.style.transform = 'none'; }
if(t.identifier === touchIds.aim) { touchIds.aim = null; joyAim.active = false; aimStick.style.transform = 'none'; }
}
};
window.addEventListener('touchstart', handleStart, {passive: false});
window.addEventListener('touchmove', handleMove, {passive: false});
window.addEventListener('touchend', handleEnd);
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);

// NOVA FUN√á√ÉO: Calcula dire√ß√£o baseada no √¢ngulo (Prioridade para o Tiro)
function getDirFromAngle(angle) {
const deg = angle * (180 / Math.PI);
if (deg >= -45 && deg <= 45) return 'Right';
if (deg > 45 && deg < 135) return 'Down';
if (deg >= 135 || deg <= -135) return 'Left';
return 'Up';
}

function update() {
if(!players.me.isDead) {
let dx = joyMove.dx, dy = joyMove.dy;
if (keys['KeyW'] || keys['ArrowUp']) dy = -1; if (keys['KeyS'] || keys['ArrowDown']) dy = 1;
if (keys['KeyA'] || keys['ArrowLeft']) dx = -1; if (keys['KeyD'] || keys['ArrowRight']) dx = 1;

// Movimento
if (dx !== 0 || dy !== 0) {
const m = Math.sqrt(dx*dx + dy*dy);
players.me.x += (dx/m) * 5; players.me.y += (dy/m) * 5;

// S√≥ atualiza dire√ß√£o baseada no movimento se N√ÉO estiver mirando/atirando
if (!joyAim.active && !isMouseDown) {
if(Math.abs(dx) > Math.abs(dy)) players.me.dir = dx > 0 ? 'Right' : 'Left'; 
else players.me.dir = dy > 0 ? 'Down' : 'Up';
}
}

// L√≥gica de Tiro e Dire√ß√£o da Sprite (Priorit√°ria)
if(joyAim.active) {
players.me.dir = getDirFromAngle(joyAim.angle);
fire(joyAim.angle);
} else if(isMouseDown) {
const angle = Math.atan2(mousePos.y - canvas.height/2, mousePos.x - canvas.width/2);
players.me.dir = getDirFromAngle(angle);
fire(angle);
}
}

runWaveLogic(); 
updateMechanics();
updateHordeHud();

if(performance.now() - lastNetUpdate > 30) { if(conn && conn.open) conn.send({ ...players.me, type: 'pos' }); }

let playerListHtml = `<div class="item-row" style="color:${players.me.color}"><span>‚óè Voc√™ (${players.me.nick})</span><span>Lvl ${players.me.lvl}</span></div>`;
if(players.peer.active) { 
players.peer.x += (players.peer.tX - players.peer.x) * 0.15; 
players.peer.y += (players.peer.tY - players.peer.y) * 0.15; 
const d = Math.floor(Math.hypot(players.peer.x-players.me.x, players.peer.y-players.me.y)/10);
playerListHtml += `<div class="item-row" style="color:${players.peer.color}"><span>‚óè ${players.peer.nick}</span><span>${d}m</span></div>`;
}
playerItemsContainer.innerHTML = playerListHtml;

let hiveListHtml = "";
if(!hive.destroyed) {
const hpP = Math.floor((hive.hp/hive.maxHp)*100);
const dist = Math.floor(Math.hypot(hive.x-players.me.x, hive.y-players.me.y)/10);
hiveListHtml += `<div class="item-row" style="color:${hpP > 30 ? '#2ecc71':'#e74c3c'}"><span>üè† Base Principal</span><span>${hpP}% (${dist}m)</span></div>`;
} else { hiveListHtml = `<div class="item-row" style="color:#e74c3c"><span>Nenhuma colmeia ativa</span></div>`; }
hiveItemsContainer.innerHTML = hiveListHtml;

camera.x = players.me.x - canvas.width/2; camera.y = players.me.y - canvas.height/2;
document.getElementById('coords').innerText = `X: ${Math.floor(players.me.x)} Y: ${Math.floor(players.me.y)}`;
}

function drawHealthBar(x, y, hp, max = 100, w = 50, h = 6, offset = 55) {
ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(x - w/2, y - offset, w, h);
ctx.fillStyle = hp > (max * 0.3) ? "#2ecc71" : "#e74c3c"; ctx.fillRect(x - w/2, y - offset, w * (hp/max), h);
}

// NOVA FUN√á√ÉO: Desenha barra de p√≥len abaixo da abelha
function drawPollenBar(x, y, pollen, w = 50, h = 6, offset = -40) {
ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(x - w/2, y - offset, w, h);
ctx.fillStyle = "#fffa65"; ctx.fillRect(x - w/2, y - offset, w * (pollen/100), h);
ctx.strokeStyle = "rgba(0,0,0,0.3)"; ctx.lineWidth = 1; ctx.strokeRect(x - w/2, y - offset, w, h);
}

function draw() {
ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,canvas.width,canvas.height);
ctx.save(); ctx.translate(-camera.x, -camera.y);
const sX = Math.floor(camera.x/TILE_SIZE)*TILE_SIZE, sY = Math.floor(camera.y/TILE_SIZE)*TILE_SIZE;
for(let x=sX; x<sX+canvas.width+TILE_SIZE; x+=TILE_SIZE) 
for(let y=sY; y<sY+canvas.height+TILE_SIZE; y+=TILE_SIZE) 
if(assets.ground.complete) ctx.drawImage(assets.ground, x, y, TILE_SIZE, TILE_SIZE);

flowers.forEach(f => {
// S√≥ desenha se n√£o for semente
if(f.growState === 'seed') return;

const sway = Math.sin(performance.now() * 0.003 + f.phase) * 5;
ctx.font = "28px Arial"; ctx.textAlign = "center";
ctx.globalAlpha = f.cooldown > 0 ? 0.5 : 1.0;
ctx.fillText(f.emoji, f.x + sway, f.y);

let emoji = f.emoji;
if(f.growState === 'sprout') emoji = "üå±";

ctx.fillText(emoji, f.x + sway, f.y);
});
ctx.globalAlpha = 1.0;

if(!hive.destroyed) {
ctx.font = "60px Arial"; ctx.textAlign = "center"; ctx.fillText("üè†", hive.x, hive.y + 20);
drawHealthBar(hive.x, hive.y, hive.hp, hive.maxHp, 100, 10, 60);
}

drawIndicators();
enemies.forEach(en => { 
ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("üêú", en.x, en.y); 
drawHealthBar(en.x, en.y, en.hp, 100, 30, 4, 30); 
});
projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); });
particles.forEach(p => {
ctx.globalAlpha = p.life;
if(p.type === 'heart') { ctx.font = "20px Arial"; ctx.fillText("‚ù§Ô∏è", p.x, p.y); }
else { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3); }
}); ctx.globalAlpha = 1.0;

const drawB = (p, c, a) => {
if(!assets.bee[p.dir].complete || p.isDead) return;
ctx.globalAlpha = a; ctx.drawImage(assets.bee[p.dir], p.x-32, p.y-32, 64, 64);
ctx.globalAlpha = 1; ctx.font = "bold 14px Segoe UI"; 
ctx.fillStyle = c; ctx.textAlign = "center"; ctx.fillText(`${p.nick} (Lvl ${p.lvl})`, p.x, p.y-40);
drawHealthBar(p.x, p.y, p.hp);
// Desenha barra de p√≥len se estiver coletando e n√£o estiver cheia
if(p.isCollecting && p.pollen < 100) {
drawPollenBar(p.x, p.y, p.pollen);
}
};
drawB(players.me, players.me.color, 1);
if(players.peer.active) drawB(players.peer, players.peer.color, 0.6);
ctx.restore();
}

function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
</script>
</body>
</html>
